# 08. MCP：代理人间的通信协议

本文档详细阐述在精炼后的架构下，MCP (Multi-Component/Agent Communication Protocol) 的实现思路。

## 核心定位：一种协议，两种插件

在新的架构中，MCP 不再由一个单独的「消息总线引擎」来承载。相反，它被视为一种**通信协议规范**，其功能由两种不同类型的插件协同完成，这使得系统更加解耦。

---

## 组件设计

### 1. `MCP_Listener` 插件

*   **插件类型：** **`listener`**
*   **职责：** 实现 MCP 的**接收端**。
*   **工作流程：**
    1.  这是一个长时程运行的插件。在其 `start()` 方法中，它会连接到底层消息中间件（例如 RabbitMQ, Redis Pub/Sub, 或是一个简单的 Node.js EventEmitter）。
    2.  它订阅发送给其宿主代理人核心 ID 的消息。
    3.  当从消息中间件收到一条消息时，它会验证消息是否符合 MCP 封包格式。
    4.  验证通过后，它将消息封包转换为核心的标准事件对象，例如：
        ```json
        {
          "source": "mcp_bus",
          "type": "mcp_message",
          "payload": { /* MCP 消息的 body */ }
        }
        ```
    5.  最后，它调用核心注入的 `eventQueue.push()` 方法，将该事件推入「内部事件队列」。

### 2. `mcp:send` 插件

*   **插件类型：** **`tool`**
*   **职责：** 实现 MCP 的**发送端**。
*   **工作流程：**
    1.  这是一个普通的、被动调用的工具。
    2.  当 LLM 决定要发送消息时，代理人核心的「执行循环」会调用此工具的 `execute` 方法。
    3.  `execute` 方法会接收到 `args`，其中包含 `target_id`, `action`, `payload` 等。
    4.  该方法将这些 `args` 组装成一个符合 MCP 规范的消息封包。
    5.  它通过一个共享的客户端，将这个消息封包发布到底层消息中间件上。

---

## 优势

这种设计将 MCP 的具体实现与核心完全解耦：

*   **可替换的消息中间件：** 代理人核心完全不知道底层使用的是 RabbitMQ 还是 Redis。我们可以通过更换 `MCP_Listener` 插件的实现，轻松地切换消息中间件，而无需对核心做任何改动。
*   **保持核心纯净：** 核心的职责被严格限定在处理其内部事件队列，所有与外部世界的异步通信都被抽象到了 `Listener` 插件中。
*   **职责清晰：** 发送（`Tool`）和接收（`Listener`）的职责被清晰地分离到两种不同类型的插件中。
