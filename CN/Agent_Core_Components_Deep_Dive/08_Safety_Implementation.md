# 16. 安全机制的权责划分与实作位置 (Safety Responsibilities & Location)

本文档详细定义了 `15_Safety_Circuit_Breakers.md` 中提到的安全机制应如何在系统的三层架构中具体实作，以确保安全性不可被绕过且符合解耦原则。

---

## 1. 权责划分总览

安全防御不是单一组件的责任，而是由「政策定义」、「即时执行」与「物理强制」三个层次共同组成。

| 层级 | 物理组件 | 角色 | 实作细节 |
| :--- | :--- | :--- | :--- |
| **策略定义层** | **Agent Design Layer** | **规则制定者** | 在代理人模板 (JSON) 中定义阈值 (如 Max Tokens)。 |
| **逻辑执行层** | **Agent Core (SafetyMonitor)** | **第一线执法者** | 在执行循环中进行计数、指纹比对与即时拦截。 |
| **环境守护层** | **Orchestrator Daemon** | **最终裁决者** | 从 OS 层级监控进程资源，执行强制终止 (Kill)。 |

---

## 2. 各层级实作细节

### 2.1 代理人设计层 (Agent Design Layer)：阈值配置
设计层不负责「跑」监控逻辑，但它决定了监控的**标准**。
*   **实作位置：** `agent_template.json`。
*   **内容：** 定义每个代理人角色的 `safety_policies`。
*   **优点：** 针对不同能力的代理人提供差异化安全标准（例如：高级代理人有更高预算，初级代理人限制较严）。

### 2.2 代理人核心 (Agent Core)：即时监控 (SafetyMonitor)
核心是安全逻辑的核心执行点，必须内嵌在执行循环中。
*   **实作位置：** 核心内部的 `SafetyMonitor` 模块（非插件，作为 Kernel 的一部分）。
*   **关键动作：**
    *   **每次循环前：** 读取来自设计层的 `safety_policies`。
    *   **LLM 调用前：** 检查累计 Token 消耗是否超标。
    *   **工具执行后：** 将工具名称与参数进行 Hash，检查是否重复调用（防止鬼打墙）。
    *   **优先级检查：** 检查 `Priority Queue` 是否有来自人类的 `SYSTEM_HALT` 指令。

### 2.3 守护层 (Orchestrator Daemon)：守护进程 (Watchdog)
当核心本身因为 Bug 失控（例如进入无响应死锁）时，由守护层执行物理熔断。
*   **实作位置：** Daemon 内部的进程监控模块。
*   **关键动作：**
    *   **资源限额：** 若 Core 进程 CPU 占用率或内存使用量超过操作系统预算，Daemon 执行 `kill -9`。
    *   **强制重置：** 接收 UI 的紧急停止请求，不经过 Core 逻辑直接终止进程。
    *   **心跳检测：** 检测 Core 是否在规定时间内完成一个 Tick，若无响应则判定为「思维冻结」，强制重启。

---

## 3. 设计优点

1.  **不可绕过性 (Non-Bypassability)**：
    即使 Agent Core 的 LLM 试图通过修改内存来关闭安全机制，由于 Daemon 从外部进行资源监控，且启动配置是由设计层强制注入的，Agent 无法自我解锁。
2.  **核心简洁性 (Clean Core)**：
    核心不需要知道「为什么」预算是 1000 Token，它只需要执行简单的「计数 > 限制」逻辑。
3.  **灵活性 (Flexibility)**：
    管理员可以在不修改任何代码的情况下，通过修改设计层的 JSON 模板，即时调整全系统的安全水位。

---

## 4. 相关引用
*   参阅 `02_Agent_Coordination_Layer.md` 了解模板定义。
*   参阅 `12_Orchestrator_Daemon_Design.md` 了解进程监控。
*   参阅 `15_Safety_Circuit_Breakers.md` 了解具体熔断逻辑。
