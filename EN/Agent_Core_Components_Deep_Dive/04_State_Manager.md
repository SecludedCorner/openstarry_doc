# Deep Dive: State Manager

This document explores the memory hub of the "Headless Agent Core"â€”the data structure and responsibilities of the State Manager.

## Core Responsibility

The State Manager is responsible for maintaining the complete context of a **single conversation session**, ensuring continuity. it primarily manages "short-term memory" (the current thinking chain) and "medium-term memory" (the full history of the current session). It is **not responsible** for "long-term memory."

---

## Data Structure Deep Dive

The core of the State Manager is a linear Message List. To accurately track the relationship between tool calls and their results, the data structure requires fine-grained detail.

```typescript
// Define message roles
type MessageRole = 'user' | 'assistant' | 'tool';

// Tool call requests initiated by the assistant
interface ToolCallRequest {
  id: string;      // Unique ID for each tool call, generated by the core
  name: string;    // Name of the tool
  args: object;    // Arguments for the tool
}

// Results of tool execution
interface ToolCallResult {
  tool_call_id: string; // Corresponding id from ToolCallRequest
  result: any;          // Return value from tool execution
  is_error: boolean;    // Flag indicating if the result is an error
}

// Unified message object
interface Message {
  id: string;           // Unique ID for the message
  timestamp: string;    // Message creation timestamp
  role: MessageRole;

  // When role is 'user' or 'assistant' (final response)
  content?: string | null;

  // When role is 'assistant' and initiating a tool call
  tool_calls?: ToolCallRequest[];

  // When role is 'tool'
  tool_results?: ToolCallResult[]; 
}
```
**Key Design:** By using `id` in the `tool_calls` list and `tool_call_id` in the `tool_results` list, we can clearly associate one or more tool call requests with their corresponding results, maintaining context accuracy even during parallel tool execution.

---

## Key Implementation Details

### 1. Truncation Strategy
To prevent the context from exceeding the LLM's token limit, the State Manager must implement a truncation strategy.
*   **Token Counter:** Real-time calculation of total tokens in the message list before adding any new message.
*   **Sliding Window:** When tokens exceed the limit, remove one or more messages from the **beginning** of the list (typically skipping the initial system prompt).
*   **Summarization:** A more advanced strategy. When history becomes too long, an asynchronous call to a tool or a specialized LLM can summarize earlier rounds of conversation. The original messages are then replaced with a summary message (`role: 'system'`, `content: 'Summary of previous context: ...'`).

### 2. Interaction with Long-term Memory Engine
The State Manager does not store long-term memory, but it acts as the **source** for it.
*   **Data Offloading:**
    *   At the end of a conversation session (`/reset` or timeout), the State Manager can send the full session history to the external "Memory & RAG Engine."
    *   The engine processes these raw dialogues in the background, extracting key entities, user preferences, and generating new knowledge to store in its knowledge base.
*   **Context Bootstrapping:** At the start of a new session, the "Agent Core" can query the "Memory & RAG Engine" for a summary of key information about the current user, pre-populating the State Manager as part of the initial system prompt.

### 3. Session Management
In practice, the system needs to handle multiple sessions for multiple users simultaneously.
*   The State Manager itself should be **stateless**, with all data (the message list) provided as input parameters.
*   Above the "Agent Core," a **Session Manager** is responsible for:
    1.  Creating and destroying sessions.
    2.  Maintaining a mapping from `session_id` to `Message[]` (the message list).
    3.  Passing the message list corresponding to the `session_id` to the State Manager for each "Execution Loop" call.
    4.  Storing this mapping in memory (e.g., Redis) or a database to support stateless horizontal scaling.
