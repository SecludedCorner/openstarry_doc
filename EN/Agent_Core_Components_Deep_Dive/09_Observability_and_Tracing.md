# 09. Observability & Tracing

This document defines how standardized logging, metrics, and tracing are implemented within the OpenStarry system, which is crucial for debugging multi-agent collaborative systems.

## 1. Tracing

In a multi-agent environment, a single user request may trigger MCP communications across multiple Agents. We must be able to trace the entire request chain.

### 1.1 Trace Context (Propagation Protocol)
The system uses a `trace_id` as a unique identifier.

*   **TraceID Generation**: Generated by the `Orchestrator Daemon` or `Gateway` at the very moment a request enters the system.
*   **Propagation Method**: Carried in the `metadata` field of the MCP message packet.
    ```json
    {
      "source": "master_agent",
      "target": "worker_007",
      "metadata": {
        "trace_id": "tr-xxxx-yyyy-zzzz",
        "parent_span_id": "span-123"
      },
      "payload": { ... }
    }
    ```
*   **Propagation Responsibility**: When an Agent Core receives an event with a `trace_id`, it must bind that ID to the current `Execution Loop` context and pass it along in generated logs and subsequent outbound messages.

---

## 2. Structured Logging

The system mandates the use of **JSON-formatted structured logs** to facilitate machine parsing and automated monitoring.

### 2.1 Log Field Specifications
Each log entry should include:
*   `timestamp`: ISO8601 format.
*   `level`: `DEBUG`, `INFO`, `WARN`, `ERROR`.
*   `agent_id`: ID of the current agent.
*   `trace_id`: The associated trace ID.
*   `module`: e.g., `Kernel`, `PluginLoader`, `SafetyMonitor`.
*   `msg`: Human-readable message.
*   `context`: (Optional) Additional key-value data.

### 2.2 Key Instrumentation Points
*   **LLM Invocations**: Record Prompt summary, Token usage, and latency.
*   **Tool Execution**: Record tool name, arguments (sanitized), and execution results.
*   **State Transitions**: Record transitions of the state machine from state A to B.
*   **Circuit Breaker Triggers**: Record the reason for the trigger and current counter values.

---

## 3. Metrics

Used for monitoring system health and costs.

*   **Cost Metrics**: `total_tokens_used`, `cost_usd` (billed per model).
*   **Performance Metrics**: `llm_latency_ms`, `tool_execution_time_ms`.
*   **Health Metrics**: `loop_error_rate`, `active_agents_count`, `mcp_message_latency`.

---

## 4. Implementation Mechanism: Everything is a Plugin

The Agent Core does not directly connect to log servers or Prometheus. It outputs through **`logger` plugins**.

*   **`ConsoleLoggerPlugin`**: Outputs JSON logs to stdout/stderr (collected by the Daemon).
*   **`FileLoggerPlugin`**: Writes logs to a specific project directory.
*   **`OpenTelemetryPlugin`**: Sends Traces and Metrics to backend analysis platforms (e.g., Jaeger, Grafana Tempo).

---

## 5. Summary

Through end-to-end TraceID propagation and JSON structured logging, we achieve:
1.  **Rapid Debugging**: Precise extraction of all steps for a specific task from massive logs.
2.  **Cost Monitoring**: Real-time tracking of expenditures for each Agent and task.
3.  **Bottleneck Analysis**: Identification of which tool or Agent is the slowest to respond.
