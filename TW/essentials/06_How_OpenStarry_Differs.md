# OpenStarry 與其他框架的不同之處

> *"Agent 的運作機制模擬為人類的認知過程，而非傳統的 Request-Response 程式。"*

## 不同的類別

AI Agent 生態系中有許多框架：LangChain、AutoGen、CrewAI、Semantic Kernel 等。每個都有其優勢。OpenStarry 不是在嘗試成為它們之中任何一個的更好版本。它佔據了一個根本不同的位置——**數位生命的作業系統**，而非建造聊天機器人的工具包。

## 七個關鍵差異

### 1. Agent 是 OS 程序，不是腳本

**典型框架**：Agent 是函式。它們醒來、執行、回傳結果、然後死去。狀態在呼叫之間遺失。記憶僅限於當前 Session。每次重啟都是全新的開始。

**OpenStarry**：Agent 是由 Daemon（`openstarryd`）管理的持久數位生物，就像 `systemd` 管理的程序。它們有生命週期：

```
緣起（Origination）→ 調度（Scheduling）→ 生起（Arising）→ 運行（Operation）→ 寂滅（Cessation）
```

它們可以休眠、喚醒、被監控、重啟，以及在運行時被檢視。記憶跨 Session 持續。狀態在重啟後存活。Agent 有 PID、資源限制和心跳。

### 2. 哲學驅動的架構（五蘊）

**典型框架**：插件系統按技術分類組織——工具、鏈、記憶、檢索器、Agent。實用，但分類是任意的，且經常重疊。

**OpenStarry**：每個插件都對應五個哲學維度之一：

| 蘊 | 插件類型 | 它回答的問題 |
|----|---------|------------|
| 色 Form | UI | Agent 如何呈現？ |
| 受 Sensation | Listener | Agent 能感知什麼？ |
| 想 Perception | Provider | Agent 如何思考？ |
| 行 Volition | Tool | Agent 能做什麼？ |
| 識 Consciousness | Guide | Agent 是誰？ |

這不是裝飾。它提供了**架構完備性**——如果你涵蓋了所有五蘊，你就涵蓋了 Agent 所需的一切。你不可能意外遺漏任何維度。這套對應已經過 2,500 年的檢驗。

一個插件可以提供多個蘊（WebSocket 插件同時提供 Listener 和 UI）。系統保持清晰，因為介面是正交的。

### 3. 絕對的微內核純度

**典型框架**：核心通常包含預設工具、內建記憶策略、硬編碼的 LLM 整合，或預設 UI。移除它們會導致問題。

**OpenStarry**：編譯後的 Core 二進位檔包含**零插件程式碼**。這不是一條指導方針——而是每次建置都會執行的自動化測試：

```bash
pnpm test:purity  # 掃描 Core 是否有任何插件匯入 → 必須為零
```

沒有插件，Core 什麼都不做。它是一個空的執行迴圈——一個沒有身體的心跳。這種極致的純度意味著：
- Core 的攻擊面極小（沒有 I/O 程式碼 = 沒有 I/O 漏洞）
- 同一個 Core 可以在 CLI、Web、WebSocket、IoT 上運行——無需修改
- 架構不會被意外汙染

> *"沒有內建程式碼，就沒有內建 Bug。"*

### 4. Headless 設計——可攜式靈魂

**典型框架**：通常耦合到特定的介面——聊天 UI、Notebook、API 伺服器。更換前端意味著更改核心。

**OpenStarry**：Core 是 Headless 的。它不知道自己穿著什麼 UI、在什麼協定上監聽，或在什麼裝置上運行。

同一個 Agent 可以同時：
- 在終端機中回應（stdio 插件）
- 接受 WebSocket 連線（transport-websocket 插件）
- 提供 HTTP API 搭配 SSE 串流（transport-http 插件）

三副身體共用同一個大腦、同樣的工具、同一個靈魂。來自任何 Listener 的事件都進入同一個事件佇列。回應透過 Transport Bridge 路由回所有已註冊的 UI。

最戲劇性的展示：**USB 隨身碟上的 Agent**。Agent 的靈魂（Prompt + 自訂插件）存在於 USB 隨身碟上。將它插入任何運行 OpenStarry 的電腦，Agent 就會甦醒——使用主機的 Core 執行環境，但保有自己的身份和能力。插到另一台電腦：同樣的靈魂，不同的身體。

### 5. 痛覺驅動的自我修正

**典型框架**：錯誤引發例外、觸發盲目重試，或終止執行。Agent 不「知道」自己失敗了——框架在 Agent 的意識之上處理錯誤。

**OpenStarry**：錯誤成為**痛覺信號**——直接注入 Agent 的上下文作為工具結果：

```
錯誤發生 → SafetyMonitor 捕捉 → Guide 插件解讀嚴重程度
→ 痛覺警報注入上下文 → LLM「感受」失敗 → 自我修正
```

三個嚴重等級：💧 輕微痛覺 → ⚡ 中度痛覺 → 🔥🔥🔥 嚴重痛覺

**挫折計數器**在痛覺被忽視時升級回應：
- 3 次相同失敗 → 系統注入「停下來分析原因」
- 5 次連續錯誤 → 強制暫停
- 10 次操作中 80% 錯誤率 → 緊急中止

這對應了生物痛覺：輕微 → 惱人 → 使人失能 → 失去意識。

關鍵洞察：**Core 提供事實，Guide 提供意義。** Core 說「EPERM at /etc/passwd。」Guide 說「這造成嚴重痛覺。你正在撞擊權限牆。停下來重新考慮。」不同的 Guide 插件可以對相同的錯誤做出不同的解讀——安全型 Agent 以謹慎回應，學習型 Agent 以好奇心回應。

### 6. 碎形多 Agent 組合

**典型框架**：多 Agent 系統有固定的拓撲——監督者-工作者、循環輪替、辯論。增加層級需要架構上的改動。

**OpenStarry**：自相似結構。單一 Agent 和一個 Agent 團隊暴露**完全相同的 MCP 介面**：

```
簡單 Agent：
  Input → LLM → Tool Calls → Output

複合 Agent（團隊）：
  Input → Coordinator Agent → [Sub-Agent A (research), Sub-Agent B (coding)] → Output

兩者都暴露：tools/list, tools/call via JSON-RPC 2.0
```

呼叫者無法分辨它對話的是單一 Agent 還是一個 50 人團隊。這使得無限層級的組合成為可能，不需要架構變更——團隊的團隊的團隊，每一個對外都表現為一個簡單的對等節點。

遞迴防護（TraceId + 深度計數器，最大 5 層）防止無限迴圈。

> *"一個 Agent 可以只是一個簡單的工具……但它也可以是一個複雜的團隊……對外，它們都暴露相同的介面。"*

### 7. 控制理論基礎

**典型框架**：執行模型是命令式的（步驟 1、步驟 2、步驟 3）或基於鏈的（LangChain 的鏈隱喻）。沒有穩定性或收斂性的形式化模型。

**OpenStarry**：Agent 被明確建模為一個**回饋控制系統**——與自動駕駛和工業機器人所用的同一套數學：

| 控制理論 | Agent 架構 |
|---------|-----------|
| 參考輸入 | 使用者目標（System Prompt + 訊息） |
| 控制器 | LLM（最小化目標-狀態誤差） |
| 控制變數 | 工具呼叫 |
| 受控對象 | 外部世界 |
| 感測器 | 工具結果 |
| 誤差信號 | 目標與現實之間的差距 |

這為三個穩定性問題提供了形式化的推理：
- **振盪**（復原/重做迴圈）→ 由上下文歷史解決（積分項）
- **發散**（目標偏移）→ 由 System Prompt 錨定解決（永不被修剪）
- **穩態誤差**（過早宣告完成）→ 由驗證步驟解決（微分項）

> **「智慧不僅僅在於擁有強大的 LLM。它在於回饋迴路的品質。」**

## 比較表

| 面向 | LangChain / CrewAI / AutoGen | OpenStarry |
|------|------------------------------|------------|
| **Agent 模型** | 腳本 / 函式呼叫 | OS 程序 / 數位生物 |
| **架構基礎** | 技術分類 | 佛學五蘊（2,500 年驗證） |
| **核心純度** | 包含預設（工具、記憶、LLM） | 零內建能力（由 `test:purity` 驗證） |
| **UI 耦合** | 耦合到特定介面 | Headless——UI 是可替換的插件 |
| **錯誤處理** | 例外 / 盲目重試 | 痛覺機制搭配嚴重等級 + 挫折計數器 |
| **多 Agent** | 固定拓撲 | 透過 MCP 碎形組合（無限層級） |
| **理論模型** | 命令式 / 鏈式 | 控制理論回饋迴路（PID 啟發） |
| **生命週期** | 執行 → 終止 | 持久化搭配 Daemon 管理（休眠/喚醒/重啟） |
| **記憶** | 框架特定、寫死 | 可插拔策略（滑動視窗 / 摘要 / 提取） |
| **安全** | 各有不同 | 3 層斷路器 + 檔案系統沙箱 + 路徑驗證 |
| **可攜性** | 依賴框架 | 可攜式靈魂——同一 Agent 跑在 CLI、Web、USB、IoT |
| **安全閾值** | 可設定的重試次數 | 具體指標：50 tick 上限、100k tokens、30s 逾時、3-strike 指紋辨識 |

## OpenStarry 不是什麼

- **不是 LangChain 的替代品**——不同的抽象層級。LangChain 串連 LLM 呼叫；OpenStarry 創造活的數位生物
- **不是聊天機器人建構器**——它是一個具備 Daemon 管理和生命週期持久化的 Agent 作業系統
- **尚未達到 Production-Ready**——v0.2.0-beta，正在積極開發中，對已完成和規劃中的部分坦誠以告
- **不試圖做所有事**——Core 刻意是空的；生態系透過插件填補空白
- **不只是理論**——118+ 測試、可運行的 CLI、WebSocket 和 HTTP Transport，真正在交付的程式碼

## 誰應該關注

- **AI Agent 研究者**——建基於哲學 + 控制理論的新穎架構，搭配穩定性的形式化推理
- **框架開發者**——極致的微內核純度作為設計研究；自動化的架構守護
- **全端開發者**——Headless 設計意味著可以建造任何前端；工廠模式意味著可以建造任何插件
- **多 Agent 建構者**——碎形 MCP 組合，實現可擴展的 Agent 團隊，不受拓撲限制
- **哲學愛好者**——真正的東西方融合，不是表面上的命名
- **開源貢獻者**——完整的 SOP 搭配品質關卡、凍結的介面，以及平行安全的開發

> *"我們不只構建 Chatbot，我們構建的是數位物種的作業系統。"*
