# 16. 安全機制的權責劃分與實作位置 (Safety Responsibilities & Location)

本文件詳細定義了 `15_Safety_Circuit_Breakers.md` 中提到的安全機制應如何在系統的三層架構中具體實作，以確保安全性不可被繞過且符合解耦原則。

---

## 1. 權責劃分總覽

安全防禦不是單一組件的責任，而是由「政策定義」、「即時執行」與「物理強制」三個層次共同組成。

| 層級 | 物理組件 | 角色 | 實作細節 |
| :--- | :--- | :--- | :--- |
| **策略定義層** | **Agent Design Layer** | **規則制定者** | 在代理人模板 (JSON) 中定義閾值 (如 Max Tokens)。 |
| **邏輯執行層** | **Agent Core (SafetyMonitor)** | **第一線執法者** | 在執行循環中進行計數、指紋比對與即時攔截。 |
| **環境守護層** | **Orchestrator Daemon** | **最終裁決者** | 從 OS 層級監控行程資源，執行強制終止 (Kill)。 |

---

## 2. 各層級實作細節

### 2.1 代理人設計層 (Agent Design Layer)：閾值配置
設計層不負責「跑」監控邏輯，但它決定了監控的**標準**。
*   **實作位置：** `agent_template.json`。
*   **內容：** 定義每個代理人角色的 `safety_policies`。
*   **優點：** 針對不同能力的代理人提供差異化安全標準（例如：高級代理人有更高預算，初級代理人限制較嚴）。

### 2.2 代理人核心 (Agent Core)：即時監控 (SafetyMonitor)
核心是安全邏輯的核心執行點，必須內嵌在執行循環中。
*   **實作位置：** 核心內部的 `SafetyMonitor` 模組（非插件，作為 Kernel 的一部分）。
*   **關鍵動作：**
    *   **每次循環前：** 讀取來自設計層的 `safety_policies`。
    *   **LLM 調用前：** 檢查累計 Token 消耗是否超標。
    *   **工具執行後：** 將工具名稱與參數進行 Hash，檢查是否重複調用（防止鬼打牆）。
    *   **優先級檢查：** 檢查 `Priority Queue` 是否有來自人類的 `SYSTEM_HALT` 指令。

### 2.3 守護層 (Orchestrator Daemon)：守護進程 (Watchdog)
當核心本身因為 Bug 失控（例如進入無響應死鎖）時，由守護層執行物理熔斷。
*   **實作位置：** Daemon 內部的進程監控模組。
*   **關鍵動作：**
    *   **資源限額：** 若 Core 行程 CPU 佔用率或記憶體使用量超過作業系統預算，Daemon 執行 `kill -9`。
    *   **強制重置：** 接收 UI 的緊急停止請求，不經過 Core 邏輯直接終止行程。
    *   **心跳檢測：** 檢測 Core 是否在規定時間內完成一個 Tick，若無響應則判定為「思維凍結」，強制重啟。

---

## 3. 設計優點

1.  **不可繞過性 (Non-Bypassability)**：
    即使 Agent Core 的 LLM 試圖透過修改內存來關閉安全機制，由於 Daemon 從外部進行資源監控，且啟動配置是由設計層強制注入的，Agent 無法自我解鎖。
2.  **核心簡潔性 (Clean Core)**：
    核心不需要知道「為什麼」預算是 1000 Token，它只需要執行簡單的「計數 > 限制」邏輯。
3.  **靈活性 (Flexibility)**：
    管理員可以在不修改任何程式碼的情況下，透過修改設計層的 JSON 模板，即時調整全系統的安全水位。

---

## 4. 相關引用
*   參閱 `02_Agent_Coordination_Layer.md` 了解模板定義。
*   參閱 `12_Orchestrator_Daemon_Design.md` 了解行程監控。
*   參閱 `15_Safety_Circuit_Breakers.md` 了解具體熔斷邏輯。
