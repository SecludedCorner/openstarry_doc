# 08. MCP：代理人間的通信協議

本文件詳細闡述在精煉後的架構下，MCP (Multi-Component/Agent Communication Protocol) 的實現思路。

## 核心定位：一種協議，兩種插件

在新的架構中，MCP 不再由一個單獨的「消息總線引擎」來承載。相反，它被視為一種**通信協議規範**，其功能由兩種不同類型的插件協同完成，這使得系統更加解耦。

---

## 組件設計

### 1. `MCP_Listener` 插件

*   **插件類型：** **`listener`**
*   **職責：** 實現 MCP 的**接收端**。
*   **工作流程：**
    1.  這是一個長時程運行的插件。在其 `start()` 方法中，它會連接到底層的消息中間件（例如 RabbitMQ, Redis Pub/Sub, 或是一個簡單的 Node.js EventEmitter）。
    2.  它訂閱發送給其宿主代理人核心 ID 的消息。
    3.  當從消息中間件收到一條消息時，它會驗證消息是否符合 MCP 封包格式。
    4.  驗證通過後，它將消息封包轉換為核心的標準事件對象，例如：
        ```json
        {
          "source": "mcp_bus",
          "type": "mcp_message",
          "payload": { /* MCP 消息的 body */ }
        }
        ```
    5.  最後，它調用核心注入的 `eventQueue.push()` 方法，將該事件推入「內部事件隊列」。

### 2. `mcp:send` 插件

*   **插件類型：** **`tool`**
*   **職責：** 實現 MCP 的**發送端**。
*   **工作流程：**
    1.  這是一個普通的、被動調用的工具。
    2.  當 LLM 決定要發送消息時，代理人核心的「執行循環」會調用此工具的 `execute` 方法。
    3.  `execute` 方法會接收到 `args`，其中包含 `target_id`, `action`, `payload` 等。
    4.  該方法將這些 `args` 組裝成一個符合 MCP 規範的消息封包。
    5.  它通過一個共享的客戶端，將這個消息封包發布到底層的消息中間件上。

---

## 優勢

這種設計將 MCP 的具體實現與核心完全解耦：

*   **可替換的消息中間件：** 代理人核心完全不知道底層使用的是 RabbitMQ 還是 Redis。我們可以通過更換 `MCP_Listener` 插件的實現，輕鬆地切換消息中間件，而無需對核心做任何改動。
*   **保持核心純淨：** 核心的職責被嚴格限定在處理其內部事件隊列，所有與外部世界的異步通信都被抽象到了 `Listener` 插件中。
*   **職責清晰：** 發送（`Tool`）和接收（`Listener`）的職責被清晰地分離到兩種不同類型的插件中。