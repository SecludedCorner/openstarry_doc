# 深度解析：プラグインインフラストラクチャの統合 (Integration)

このドキュメントでは、「プラグインインフラストラクチャ」が「ヘッドレス・エージェントコア」によってどのように統合され、使用されるかについて深く掘り下げます。

## コア・ポジショニング：コアの「デバイスマネージャー」

プラグインインフラストラクチャの「ロードエンジン」は、複数の場所で共有可能な汎用ライブラリですが、エージェントコアの内部では、オペレーティングシステムの「デバイスマネージャー」に似た役割を果たします。コア自体には、エンジンによってロードされたプラグインを「配線 (Wiring)」し、管理するための一連の **レジストリ (Registries)** と **マネージャー (Managers)** が含まれています。

## コア内部のレジストリとマネージャー

*   **`ToolRegistry` (ツールレジストリ)：**
    *   **責務：** 現在のセッションで利用可能なすべての `Tool` プラグインのリストを維持します。
    *   **機能：** `register`, `unregister`, `getTool(name)`, `getToolDefinitions()` などのメソッドを提供します。 `getToolDefinitions()` メソッドは特に重要で、「実行ループ」が LLM に送信するための、フォーマットされたツール説明リストを生成します。

*   **`ProviderManager` (プロバイダーマネージャー)：**
    *   **責務：** ロードされたすべての `Provider` プラグインを管理し、現在どれがアクティブであるかを維持します。
    *   **機能：** `add(provider)`, `setActive(providerName)`, `getActive()` などのメソッドを提供します。

*   **`UIManager` (UI マネージャー)：**
    *   **責務：** ロードされた `UI` プラグインを、コアの「双方向通信インターフェース」と接続する役割を担います。

## ワークフロー：起動と実行

1.  **コアの起動：**
    *   エージェントコアのインスタンスが作成されます。
    *   コア内部で `ToolRegistry`, `ProviderManager`, `UIManager` などのコンポーネントがインスタンス化されます。

2.  **ローダーのインスタンス化：**
    *   コアは汎用的な `PluginLoader` インスタンスを作成し、そこに **コア自身に向けた** 登録戦略 (Handlers) を注入します。
    *   例えば、 `tool` タイプのプラグインの場合、その登録戦略は `this.toolRegistry.register(plugin)` を呼び出すことです。

3.  **プラグインのロード：**
    *   コアは `PluginLoader` に対して、設定されたプラグインディレクトリからすべてのプラグインをロードするように指示します。
    *   `PluginLoader` はプラグインのロードに成功するたびに、その `type` に応じた登録戦略を呼び出し、プラグインを正しいマネージャーに「配線」します。

4.  **実行時の使用：**
    *   「実行ループ」の「コンテキストのパッケージ化」フェーズにおいて、 `toolRegistry.getToolDefinitions()` を呼び出して現在利用可能なすべてのツールの説明を取得し、それを LLM に送信するプロンプトに含めます。
    *   ツールの実行が必要になったとき、 `toolRegistry.getTool(name)` を呼び出してツールインスタンスを取得し、それを実行します。

この設計は、汎用的なロードメカニズムと具体的な統合ロジックを分離することで、コアがその機能を柔軟に管理できるようにすると同時に、コードの清潔さと高い凝集性を維持しています。
