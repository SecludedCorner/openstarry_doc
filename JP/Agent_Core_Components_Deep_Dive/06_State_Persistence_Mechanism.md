# 14. 状態管理と永続化メカニズム (State Management & Persistence)

このドキュメントでは、 OpenStarry システムが「クラッシュからの回復 (Crash Recovery)」と「状態の一貫性」をどのように実現するかを定義します。

設計は **「コアが状態を定義し、プラグインがストレージを担当する」** という原則に従い、エージェントコアをステートレス (Stateless) かつ軽量に保ちつつ、複雑な I/O 操作を専用のプラグインに委託します。

## 1. 核心となる概念：スナップショット (The Snapshot)

コアを簡潔に保つため、エージェントコアは実行時に純粋な JSON 形式の状態オブジェクトを維持します。これを **`AgentSnapshot`** と呼びます。

### 1.1 `AgentSnapshot` のデータ構造

これはコアとストレージプラグインの間の唯一の契約です。コアはこのオブジェクトを生成することのみを担当し、それがどのように保存されるかには関与しません。

```json
{
  "agent_id": "worker_007",
  "tick_index": 42,            // 論理クロック。ループが実行されるたびに +1 される
  "timestamp": 1706582400000,  // スナップショット生成時間
  "status": "WAITING_FOR_EVENT", // 現在のステートマシンの状態
  "memory": {
    "short_term_history": [    // 現在のコンテキストウィンドウ内の対話
      { "role": "user", "content": "..." },
      { "role": "assistant", "content": "..." }
    ],
    "working_variables": {     // エージェントが現在保持している変数
      "current_file_path": "/tmp/report.txt",
      "retry_count": 0
    }
  },
  "event_queue_backup": [      // まだ処理されていないイベント (現場復帰用)
    { "source": "mcp", "type": "task", "payload": "..." }
  ]
}
```

---

## 2. アーキテクチャ設計：ストレージプラグイン (Storage Plugin)

「すべてはプラグインである」という原則に基づき、永続化レイヤーは新しいプラグインタイプとして抽象化されます。

### 2.1 新しいプラグインタイプ： `storage`

*   **責務：** `AgentSnapshot` の CRUD 操作を実装します。
*   **インターフェース定義 (Interface)：**
    すべての `storage` プラグインは、以下のメソッドを実装する必要があります。
    *   `save(snapshot: AgentSnapshot): Promise<void>`
    *   `load(agent_id: string): Promise<AgentSnapshot | null>`
    *   `delete(agent_id: string): Promise<void>`

### 2.2 実装例

*   **`FileStoragePlugin` (開発環境)：** スナップショットを `.json` ファイルとして保存します (例: `./data/snapshots/worker_007.json` )。
*   **`RedisStoragePlugin` (本番環境)：** スナップショットをシリアル化して Redis のキーに保存します。極めて高い読み書き速度をサポートします。
*   **`SQLiteStoragePlugin` (エッジコンピューティング)：** ローカルの SQLite データベースファイルに保存し、 ACID トランザクションを保証します。

---

## 3. ワークフロー (The Workflow)

### 3.1 起動と復元 (Hydration)

`Orchestrator Daemon` がエージェントコアのプロセスを起動するとき：

1.  **コアの起動：** インスタンス化され、 `PluginLoader` をロードします。
2.  **ストレージプラグインのロード：** `PluginLoader` は設定に基づき、指定された `storage` プラグイン (例: `RedisStorage` ) をロードします。
3.  **状態のリクエスト：** コアは `await storage.load(my_agent_id)` を呼び出します。
4.  **状態の注入 (Hydration)：**
    *   **保存データがある場合：** コアは `AgentSnapshot` 内のデータを自身のメモリ変数に埋めます（ `tick_index`, `history`, `event_queue` を復元）。 **エージェントは「復活」し、クラッシュ前のすべてを覚えています。**
    *   **保存データがない場合：** コアは完全に新しい空白の状態で初期化されます。

### 3.2 実行時の永続化 (Runtime Persistence)

「厳格な」データの安全性を確保するため、 **「書き込み後の保存 (Save-After-Write)」** 戦略を採用しています。

**`01_Execution_Loop`** の各サイクルの最後で：

1.  **イベント処理完了：** LLM の思考が完了し、ツールの実行が完了します。
2.  **状態の更新：** コアはメモリ内の `history` と `variables` を更新します。
3.  **保存のトリガー：** コアは `await storage.save(current_snapshot)` を呼び出します。
4.  **外部への応答：** ** `save` が正常に返された後にのみ**、コアは UI への応答を送信したり、次のアクションを実行したりします。
    *   *これにより、応答前にシステムがクラッシュした場合でも、再起動後に直前の実行結果が失われず、保存済みだが未応答のステップが重複して実行されることも防げます（べき等性の設計が必要です）。*

---

## 4. 「状態」と「記憶」の区別

アーキテクチャ内では、混乱を避けるためにこれら2つの概念を厳格に区別する必要があります。

| 特性 | **状態 (State / Persistence)** | **記憶 (Memory / RAG)** |
| :--- | :--- | :--- |
| **目的** | **生存** (Crash Recovery) | **知識** (Knowledge Retrieval) |
| **保存内容** | 完全なコンテキストスタック (Stack), 変数 | 処理済みのドキュメント, 経験の要約 |
| **保存場所** | `storage` プラグイン (Redis/SQL) | `RAG Engine` (ベクトル DB) |
| **ライフサイクル** | タスク終了時に削除可能 (Ephemeral) | 永久保存 (Long-term) |
| **責任者** | **エージェントコアが直接管理** | **支援エンジンの外部サービス** |

---

## 5. まとめ

`storage` プラグインインターフェースを導入することで：

1.  **コアは純粋に保たれます：** 特定のデータベースドライバに依存する必要がなく、単に `save()` / `load()` を呼び出すだけです。
2.  **究極の柔軟性：** ユーザーはプラグインを交換するだけで、コアのコードを修正することなく、永続化レイヤーをローカルファイルからクラウドデータベースへとシームレスに切り替えることができます。
3.  **高い信頼性：** デーモンの再起動メカニズムと組み合わせることで、システムは「決して忘れない」堅牢性を実現します。
