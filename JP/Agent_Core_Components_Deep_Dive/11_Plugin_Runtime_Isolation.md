# 11. プラグイン実行時の隔離とサンドボックスメカニズム (Plugin Runtime Isolation)

このドキュメントでは、 OpenStarry システムにおいて、悪意のあるプラグインやバグの多いプラグインがコアのクラッシュ、データ漏洩、またはリソースの枯渇を引き起こすのを防ぐために、プラグインの実行環境をどのように隔離するかを定義します。

## 1. リスクモデル

*   **安定性リスク**: プラグインが未キャッチの例外 (Uncaught Exception) をスローし、メインプロセスが終了してしまう。
*   **リソースリスク**: プラグインが `while(true)` などの無限ループを書いたり、メモリ漏洩 (Memory Leak) を起こしたりする。
*   **セキュリティリスク**: プラグインが環境変数内の API Key を読み取ったり、ファイルシステム上のファイルを勝手に削除したりする。

## 2. 隔離レベル戦略 (Isolation Levels)

デプロイ環境とセキュリティニーズに応じて、システムは4つの隔離レベルをサポートします。

### レベル 1：関数レベルのラッピング (Function Wrapping) - [開発/軽量モード]
*   **メカニズム**: すべてのプラグインコードはメインプロセス (Agent Core) 内で実行されます。
*   **防護**:
    *   **Try-Catch**: `PluginLoader` はプラグインの `execute` メソッドを `try-catch` でラップすることを強制します。
    *   **Timeout**: `Promise.race` を使用して実行タイムアウト（例：10秒）を設定し、タイムアウトした場合はエラーをスローします。
*   **欠点**: `while(true)` （イベントループを占有する）を防ぐことができず、ファイルシステムへのアクセスを制限することもできません。
*   **適用**: 内部の信頼できるプラグイン、開発・デバッグ段階。

### レベル 2：仮想マシンサンドボックス (VM Sandboxing) - [標準モード]
*   **メカニズム**: Node.js の `vm` モジュールまたは `vm2` ライブラリを使用してプラグインコードを実行します。
*   **防護**:
    *   **Context Isolation**: プラグインはグローバルな `process` オブジェクトにアクセスできず、環境変数を読み取ることもできません。
    *   **Limited Access**: コアが明示的に注入した API ( `log`, `fetch` など) のみを呼び出せます。
*   **欠点**: 依然として同一プロセス内にあるため、 CPU 集約型の攻撃を完全に防ぐことはできません。
*   **適用**: サードパーティのコードを実行するが、ある程度の信頼性があるシナリオ。

### レベル 3：プロセスレベルの隔離 (Process Isolation) - [厳格/本番モード]
*   **メカニズム**: **Orchestrator Daemon** が各プラグイン（またはプラグイングループ）に対して独立した OS 子プロセス (Child Process) または Worker Thread を起動します。
*   **通信**: コアとプラグインの間で、 IPC (Inter-Process Communication) または標準入出力 (stdio) を介して JSON メッセージをやり取りします。
*   **防護**:
    *   **リソースクォータ**: デーモンは OS のメカニズム (cgroups, Docker) を使用して、プラグインプロセスの CPU/RAM を制限できます。
    *   **物理的遮断**: プラグインのデッドロックはコアに影響を与えず、デーモンはプラグインプロセスを直接 `kill` できます。
*   **欠点**: パフォーマンスのオーバーヘッドが大きく、 IPC 通信に遅延が生じます。
*   **適用**: 高リスクなコード（ Code Interpreter など）の実行、またはマルチテナント環境。

### レベル 4：WebAssembly (WASM) - [将来の進化/究極の安全]
*   **メカニズム**: プラグインを WASM モジュールとしてコンパイルし、コアに組み込まれた WASM ランタイム（ Wasmtime など）で実行します。
*   **優位性**:
    *   **メモリ安全性**: プラグインはサンドボックス外のメモリ空間にアクセスできません。
    *   **能力ベースの認可 (Capability-based)**: WASI インターフェースを通じて、プラグインのファイルおよびネットワークアクセス権限を極めて詳細に制御できます。
    *   **超高速起動**: ミリ秒単位のコールドスタートが可能で、プロセス隔離よりもはるかに高速です。
*   **適用**: 高性能計算ツール、信頼できないサードパーティ製ビジネスプラグイン。

---

## 3. 推奨される実装パス (Implementation Path)

### MVP 段階
**レベル 1 (Try-Catch + Timeout)** を採用します。
*   悪意のないほとんどのバグに対処するにはこれで十分です。
*   開発コストが最も低く済みます。

### V1.0 本番段階
**Code Interpreter** や **サードパーティ製プラグイン** に対しては、必ず **レベル 3 (独立プロセス)** を採用する必要があります。
*   `Infrastructure Plugins` （ローカル Broker など）は本質的にレベル 3 の体現であり、デーモンによって独立して管理されます。
*   機密性の高い操作を伴う通常の `Tool` プラグインは、 `Plugin Runner` を通じて独立して実行されるべきです。

---

## 4. 権限宣言 (Permission Manifest)

各プラグインの `plugin.json` は、必要な権限を宣言しなければならず、ユーザーはインストール時にそれを認可します（ Android アプリと同様）。

```json
{
  "name": "FileSearchTool",
  "permissions": [
    "fs:read:./data",  // data ディレクトリの読み取りを許可
    "network:none"     // ネットワーク接続を禁止
  ]
}
```

コアはプラグインをロードする際、これらの宣言に基づいて制限された実行コンテキスト (Context) を構築します。
