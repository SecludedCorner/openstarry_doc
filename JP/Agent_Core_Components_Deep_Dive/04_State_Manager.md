# 深度解析：ステートマネージャー (State Manager)

このドキュメントでは、「ヘッドレス・エージェントコア」の記憶の中枢であるステートマネージャーのデータ構造と責務について深く掘り下げます。

## 核心的な責務

ステートマネージャーは、 **単一の対話セッション** の完全なコンテキストを維持し、対話の連続性を確保する責任を負います。主に「短期記憶」（現在処理中の思考チェーン）と「中期記憶」（今回のセッションの完全な履歴）を管理します。「長期記憶」については **担当しません** 。

---

## データ構造の深度解析

ステートマネージャーの核となるのは、線形なメッセージリスト (Message List) です。ツール呼び出しとその結果の間の関係を正確に追跡するために、データ構造はさらに詳細である必要があります。

```typescript
// メッセージのタイプを定義
type MessageRole = 'user' | 'assistant' | 'tool';

// アシスタントが発行したツール呼び出しリクエスト
interface ToolCallRequest {
  id: string;      // 各ツール呼び出しの一意の ID。コアによって生成される
  name: string;    // ツール名
  args: object;    // ツール引数
}

// ツール実行の結果
interface ToolCallResult {
  tool_call_id: string; // ToolCallRequest の id に対応
  result: any;          // ツール実行の戻り値
  is_error: boolean;    // 結果がエラーであるかどうかを示すフラグ
}

// 統合されたメッセージオブジェクト
interface Message {
  id: string;           // メッセージの一意の ID
  timestamp: string;    // メッセージ作成時間
  role: MessageRole;

  // role が 'user' または 'assistant' （最終回答）の場合
  content?: string | null;

  // role が 'assistant' で、ツール呼び出しを発行する場合
  tool_calls?: ToolCallRequest[];

  // role が 'tool' の場合
  tool_results?: ToolCallResult[]; 
}
```
**重要な設計：** `tool_calls` リスト内の `id` と `tool_results` リスト内の `tool_call_id` を介して、1つまたは複数のツール呼び出しリクエストとその対応する結果を明確に関連付けることができます。これにより、複数のツールが並行して呼び出される状況でも、コンテキストの正確性を維持できます。

---

## 重要な実装の詳細

### 1. 記憶の切り詰め戦略 (Truncation Strategy)
コンテキストが LLM の Token 制限を超えないように、ステートマネージャーは切り詰め戦略を実装する必要があります。
*   **Token カウンター：** 新しいメッセージを追加する前に、現在のメッセージリストの総 Token 数をリアルタイムで計算します。
*   **スライディングウィンドウ (Sliding Window)：** Token が制限を超えた場合、リストの **先頭** （つまり最も古いメッセージ。ただし、通常は最初のシステムプロンプトはスキップします）から1つまたは複数のメッセージを削除します。
*   **対話の要約 (Summarization)：** より高度な戦略です。履歴が長くなりすぎた場合、ツールまたは専用の LLM を非同期で呼び出して、初期の数ターンの対話を要約します。そして、要約された複数の元のメッセージを、 `role: 'system'` および `content: '前文の要約：...'` を含む1つの要約メッセージに置き換えます。

### 2. 長期記憶エンジンとの対話
ステートマネージャー自体は長期記憶を保存しませんが、長期記憶の **ソース（供給源）** となります。
*   **データのレポート/オフロード (Data Offloading)：**
    *   対話セッションが終了したとき（ `/reset` またはタイムアウト）、ステートマネージャーは今回のセッションの完全な履歴を外部の「記憶および RAG エンジン」に送信できます。
    *   「記憶および RAG エンジン」はこれらの生の対話を受け取ると、バックグラウンドで非同期処理を行い、重要なエンティティやユーザーの好みを抽出し、新しい知識を生成して自身のナレッジベースに保存します。
*   **コンテキストのブートストラッピング (Bootstrapping Context)：** 新しい対話セッションが開始されるとき、「エージェントコア」はまず「記憶および RAG エンジン」に対して現在のユーザーに関する重要な情報の要約を照会し、それを初期システムプロンプトの一部としてステートマネージャーにあらかじめ入力しておくことができます。

### 3. セッション管理 (Session Management)
実際のアプリケーションでは、システムは複数のユーザーの複数のセッションを同時に処理する必要があります。
*   ステートマネージャー自体は **ステートレス（無状態）** であるべきで、そのすべてのデータ（メッセージリスト）は渡されたパラメータから取得されます。
*   「エージェントコア」の上層に、以下の責任を担う **「セッションマネージャー」 (Session Manager)** が存在すべきです。
    1.  セッションの作成と破棄。
    2.  `session_id` から `Message[]` （メッセージリスト）へのマッピングの維持。
    3.  「実行ループ」を呼び出すたびに、対応する `session_id` のメッセージリストをステートマネージャーに渡して操作を行う。
    4.  このマッピングをメモリ（ Redis など）またはデータベースに保存し、ステートレスな水平スケーリングをサポートできるようにする。
