# 17. ホスト引導パターン (Host Bootstrapping Pattern)

このドキュメントでは、古典的なアーキテクチャのパラドックスに答えます。 **「エージェントコアが絶対的に純粋で I/O 能力を持たないのなら、どうやってハードディスク上の設定を読み込み、プラグインをロードするのか？」**

答えは、 **「コアは読み込みもロードもしない。それらはすべて『ホスト (Host)』の仕事である」** ということです。

## 1. 問題：鶏が先か卵が先か (The Bootstrap Paradox)

私たちは `packages/core` に対して以下を要求しています。
1.  **ヘッドレス (Headless):** 実行環境を知らない。
2.  **純粋 (Pure):** Node.js の `fs` や `module` モジュールに依存しない。
3.  **マイクロカーネル (Microkernel):** すべての能力（ファイルの読み込みを含む）がプラグインから提供される。

しかし、もしファイルの読み込みすらできないのであれば、どうやって `agent.json` を読み込んで、自身が `fs-plugin` をロードする必要があることを知るのでしょうか？

## 2. 解決策：ホストレイヤー (The Host Layer)

アーキテクチャにおいて、2つのランタイムロールを明確に区別しています。

### ロール A：ホスト (Host / Coordinator)
*   **実体：** `apps/runner`, `apps/daemon`, `apps/web-server`。
*   **権限：** 完全な OS 権限（ファイルの読み書き、ネットワークリクエスト、プロセス管理）を持つ。
*   **責務：** **開拓者**。環境の準備、設定の読み込み、プラグインのハードディスクからメモリへの運搬を担当します。

### ロール B：カーネル (Core)
*   **実体：** `packages/core` のインスタンス。
*   **権限：** ゼロ。
*   **責務：** **継承者**。ホストが準備したリソースを受動的に受け取り、論理演算を開始します。

## 3. 起動シーケンスの詳細 (The Sequence)

### ステップ 1. ホストの目覚め (Host Awake)
ユーザーが `node apps/runner/dist/bin.js` を実行したとき、起動するのは **ホスト (Runner)** です。
このとき、ホストはネイティブの `fs` モジュールを使用して `./agent.json` を読み込みます。

> **ホストの視点：** 「設定を読み込んだ。このエージェントには `fs` と `http` プラグインが必要だ」

### ステップ 2. 物理的なロード (Physical Loading)
ホストは設定に基づき、各プラグインに対して2つの解決戦略を試みます。(1) `ref.path` で指定されたファイルパス、(2) `import(ref.name)` によるパッケージ名の動的ロードです。ESM の `import()` を使用して、それらをメモリにロードします。

> **ホストの視点：** 「 `fs-plugin.js` を RAM にロードした。これは現在オブジェクトになっている」

### ステップ 3. 依存性の注入 (Injection)
ホストはコアをインスタンス化し、これらの **ロード済みのオブジェクト** をコアに渡します。

```typescript
// ホストのコード (疑似コード)
const loadedPlugins = [ fsPluginObject, httpPluginObject ];
const core = new AgentCore({ plugins: loadedPlugins });
```

### ステップ 4. カーネルの目覚め (Core Awake)
コアが起動します。コアはプラグインがすでに手元にあるため、ハードディスクを探す必要はありません。 `plugin.initialize()` を呼び出すだけで済みます。

> **コアの視点：** 「目が覚めた。手元にツールがある。これらのツールがどこから来たのかは知らないが、使うことはできる」

## 4. まとめ

**調整レイヤー (ホスト) は「生存」を担当し、コア (カーネル) は「生活」を担当します。**

*   **どのプラグインをロードするか？** -> フォルダの内容を確認する必要がある -> これは **ホスト** の仕事です。
*   **プラグインをどう使うか？** -> これは **コア** の仕事です。

このパターンにより、コアの絶対的な純粋さを維持しつつ、物理的なロードの問題を解決しています。
