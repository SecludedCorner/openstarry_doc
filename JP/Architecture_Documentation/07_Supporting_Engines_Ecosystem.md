# 06. 支援エンジンエコシステム (Supporting Engines Ecosystem)

「エージェントコア」（対話実行用）と「エージェント調整レイヤー」（ワークフロー・オーケストレーション用）以外に、完全な本番レベルのエージェントシステムを構築するには、一連の独立した専門的な「支援エンジン」が必要です。

## 設計上の決定：組み込み機能 vs. 外部サービス

当然の疑問として、これらのエンジン（記憶、セキュリティなど）の機能をエージェントコアに直接組み込むべきでしょうか？

答えは「いいえ」です。これらの複雑な機能をコアの**組み込み部分**ではなく、**独立した外部サービス（エンジン）**として扱うことが、拡張性とメンテナンス性の高いシステムを構築するための鍵となります。

オペレーティングシステムの設計哲学をもう一度借りて理解しましょう。**エージェントコアは「カーネル」 (Kernel) であり、これらの支援エンジンはカーネル上で動作する独立した「サービスプログラム」 (Server Programs) です。**

*   **カーネル**は基礎的な能力（プロセスのスケジューリング、メモリ管理、ファイル I/O）を提供しますが、カーネル自体にデータベースや CI/CD ツールが含まれているわけではありません。
*   **データベース (PostgreSQL など)** は独立したサービスとして動作し、カーネルの I/O 能力を利用して膨大なデータの保存やクエリを行います。
*   **CI/CD プラットフォーム (Jenkins など)** は、他のアプリケーションをスケジュールしテストするための独立したツールとして機能します。

機能を独立したエンジンに分離することの利点は以下の通りです。

*   **単一責任の原則：** エージェントコアを軽量に保ち、対話の調整だけに専念させることで、メンテナンスが容易になります。
*   **独立した拡張性：** 記憶エンジン（データ集約型）とエージェントコア（計算集約型）では拡張の方法が異なります。分離することで、それぞれを独立して拡張できます。
*   **再利用と集中化：** 1つの記憶エンジンやポリシーエンジンを数百、数千のエージェントインスタンスで共有でき、データとルールの整合性が確保されます。
*   **チームの専門化：** 異なるチームがそれぞれのエンジンの最適化に専念できます。

---

## デプロイモード：サービス vs. プラグイン

これらのエンジンは論理的には独立していますが、物理的なデプロイにおいては、異なる規模のニーズに適応するために2つのモードをサポートしています。

1.  **リモート・マイクロサービス・モード (Remote Microservices):** 
    *   大規模な本番環境に適しています。
    *   エンジンは独立した Docker コンテナまたは Serverless 関数（AWS Lambda、K8s Pods など）として動作します。
    *   エージェントは標準的なネットワークプロトコル (HTTP/gRPC) を介してそれらにアクセスします。

2.  **ローカル・インフラ・プラグイン・モード (Local Infrastructure Plugins):**
    *   ローカル開発や軽量なデプロイに適しています。
    *   エンジンは `infrastructure` タイプのプラグインとしてパッケージ化され、 **オーケストレーターデーモン (Orchestrator Daemon)** によって直接ロードおよび実行されます。
    *   例えば、 `Local_VectorDB_Plugin` は、すべてのエージェントが共有して使用できる組み込みの ChromaDB インスタンスをローカルで起動できます。

---

## 3つの主要な支援エンジン

### 1. 記憶および RAG エンジン (Memory & RAG Engine)

*   **位置付け：** エージェントエコシステムの「図書館」兼「公文書保管庫」であり、統合された知識と記憶のセンターです。
*   **類推：** 独立した**データベースサービス (Elasticsearch + PostgreSQL など)**。
*   **主な責務：**
    1.  **データの取り込みとベクトル化：** さまざまなソースからのデータを処理し、分割し、ベクトル化するための自動化されたパイプラインを提供します。
    2.  **ナレッジベース管理：** 基盤となるベクトルデータベースとメタデータを管理します。
    3.  **複雑なクエリ：** ハイブリッド検索やフィルタリングなどの機能をサポートする高度なクエリインターフェースを提供します。
    4.  **長期記憶の合成：** 対話のリフレクションを通じて、エージェントのために構造化された長期記憶を能動的に生成します。
*   **協調方法：** 「エージェントコア」はこのエンジンにクエリを発行してコンテキスト情報を取得します。

### 2. 評価およびテストエンジン (Evaluation & Testing Engine)

*   **位置付け：** エージェントエコシステムの「品質管理部 (QC)」。
*   **類推：** 独立した**CI/CD およびテストプラットフォーム (Jenkins など)**。
*   **主な責務：**
    1.  **テストケース管理：** 評価に使用する標準データセットを維持します。
    2.  **評価の実行：** エージェントやワークフローをテストケースに対してバッチ処理で、繰り返し実行します。
    3.  **メトリクス計算：** 回答の忠実性、ツールの使用精度、コスト、遅延などの主要な指標を自動的に計算します。
    4.  **結果レポート：** 異なるバージョンのエージェントのパフォーマンスを比較するための視覚的なレポートを生成します。
*   **協調方法：** 開発者はこのエンジンを使用して、開発したエージェントコアや調整レイヤーのワークフローを「実行」し「テスト」します。

### 3. ポリシーおよびガードレールエンジン (Policy & Guardrails Engine)

*   **位置付け：** エージェントエコシステムの「警備およびコンプライアンス部」。
*   **類推：** 独立した**エンタープライズ級の認証・認可センター (Active Directory など)**。
*   **主な責務：**
    1.  **ポリシー定義：** きめ細かなセキュリティ、プライバシー、行動ポリシー（例：アクセスできるファイル、呼び出せる API、コンテンツ生成で遵守すべきルールなど）を定義するための言語を提供します。
    2.  **ポリシー実行：** 重要な操作を実行する前に、他のコンポーネントが権限チェックを行うための高性能なクエリインターフェースを提供します。
    3.  **監査ログ：** セキュリティ監査のためにすべてのポリシー決定を記録します。
*   **協調方法：** 「エージェントコア」の「セキュリティレイヤー」は、ツールの呼び出しリクエストを受け取った際、単にユーザーに尋ねるのではなく、このエンジンに「許可されているか」のクエリを発行します。