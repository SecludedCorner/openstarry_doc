# 10. 能力プラグイン設計：エージェントマネージャー

このドキュメントでは、最終的なアーキテクチャにおける `AgentManagerTool` の設計と責務について詳しく説明します。

## コア・ポジショニング：意思決定者であり、実行者ではない

`Orchestrator Daemon` を導入した最終的なアーキテクチャにおいて、 `AgentManagerTool` の役割はさらに純粋化されました。それは、OS プロセスを作成するという「泥臭い作業」を自ら実行するのではなく、 **「意思決定インターフェース」** としての役割を担います。

「マスターエージェント」の LLM が下した「新しいエージェントが必要だ」という **意思決定** を、 `Daemon` に対する **標準化されたリクエスト** に変換する責任を負います。

---

## `AgentManagerTool` の設計

*   **プラグインタイプ：** `tool`

*   **提供されるメソッド (独立したツールとして):**
    *   **`agent:start(agent_id: string, template_id: string)`**
        *   **機能：** 事前定義されたテンプレートに基づいて新しいワーカーエージェントを作成し起動するよう、 `Orchestrator Daemon` に **リクエスト** します。
        *   **実装：** このメソッドの `execute` ロジックは非常にシンプルになりました。
            1.  `{ "agent_id": "...", "template_id": "..." }` のような JSON リクエストボディを構築します。
            2.  `Orchestrator Daemon` が公開している管理 API エンドポイント（例： `http://localhost:5050/agents`）に `POST` リクエストを送信します。
            3.  `Daemon` の API からの応答（成功ステータスと `agent_id` を含む JSON など）を待ち、それを LLM に返します。
    *   **`agent:stop(agent_id: string)`**
        *   **機能：** 実行中のワーカーエージェントを停止し破棄するよう、 `Orchestrator Daemon` に **リクエスト** します。
        *   **実装：** `Daemon` の API エンドポイント（例： `http://localhost:5050/agents/{agent_id}`）に `DELETE` リクエストを送信します。
    *   **`agent:status(agent_id: string)`**
    *   **`agent:list()`**
        *   **実装：** 同様に、これらのメソッドは `Daemon` 管理 API への `GET` リクエストに変換されます。

---

## まとめ

この設計の利点は明らかです。

*   **責任の分離：**
    *   **マスターエージェント (LLM):** 最高レベルのビジネス上の意思決定（ **Why & What** - なぜエージェントが必要か、どのようなエージェントが必要か）を担当します。
    *   **`AgentManagerTool`:** 意思決定を標準的な API リクエストに変換する（ **How to Ask** - どのように作成リクエストを出すか）を担当します。
    *   **`Orchestrator Daemon`:** OS に関連するすべての低層の実装詳細（ **How to Do** - どのように実際にプロセスを作成し管理するか）を担当します。
*   **拡張性：** この API ベースの設計により、将来的に `Daemon` を複数のマシン上で分散してエージェントを作成できるクラスターマネージャーに拡張することが容易になります。その際、 `AgentManagerTool` のインターフェースを変更する必要はありません。
*   **セキュリティ：** プロセスの作成・破棄に関するすべての権限が `Daemon` に集約されるため、統一された監査や権限管理が行いやすくなります。