# 27. システムトポロジと管理レイヤーアーキテクチャ (System Topology & Management Zone)

このドキュメントでは、 OpenStarry のマクロな運用ロジックを定義します。これは、「管理レイヤー」が土壌と養分を提供し、「コアレイヤー」が「プラグイン」を通じて種の多様性を実現する、現代的な AI オペレーティングシステムです。

---

## 1. エージェント調整レイヤー (The Management Zone)

**位置付け：システムのホスト環境 (Host) および行政の中枢。**
このレイヤーは「思考」を担当するのではなく、「思考環境の安定と安全を確保すること」を担当します。

### 1.1 コンテナレイヤー (Plumbing)
*   **メカニズム**：動的リンクまたはコンテナ化技術（ WebAssembly サンドボックスや特定のプロセス分離など）を採用。
*   **責務**： `AgentLoader` を実装。システムが「開発者」を必要とするとき、コンテナレイヤーはレジストリから `AgentCore` イメージを取得し、指定された `Plugins` を **依存性の注入 (DI)** を介してマウントします。

### 1.2 計画およびスケジューリングレイヤー (Orchestration)
*   **メカニズム**： **因果連鎖 (Causality Chain)** に基づくイベント駆動型アーキテクチャ。
*   **責務**：エージェントのプライベートな内部状態を監視するのではなく、 **「境界イベント」** を監視します。エージェント A が `TaskCompleted` イベントを発行した際、スケジューリングレイヤーはそれがエージェント B を呼び覚ますための「縁」であるかどうかを判断します。

### 1.3 ポリシーおよびセキュリティレイヤー (Policy)
*   **メカニズム**：インターセプター (Interceptors) およびリソース割り当て管理 (Quota Management)。
*   **責務**： 「戒律」を執行します。例えば、テスト用エージェントのネットワークアクセス権限を制限したり、開発用エージェントの Token 使用予算を強制的に制限したりします。

### 1.4 リソースおよび環境レイヤー (Environment)
*   **メカニズム**：ハードウェア抽象化レイヤー (HAL)。
*   **責務**：物理的な実体（ PiKVM の画面、 NVIDIA Jetson の温度など）を標準的な **感覚データストリーム** に変換してエージェントに供給します。

### 1.5 多元対話レイヤー (Interface)
*   **メカニズム**：状態投影 (State Projection)。
*   **責務**：目に見えないエージェントの思考プロセス（プロトコルプラグインからのエクスポートデータ）を、人間が読めるダッシュボードに変換します。

---

## 2. エージェントコア (The Autonomous Life Zone)

**位置付け：純粋な「五蘊」計算サイクル。**
コアは空であり、その唯一の責務は **サイクルの実行を維持すること** です。

### 五蘊能力レイヤー (Aggregate)
*   **受 (Input)**：環境レイヤーからの信号を受信。
*   **想 (Reasoning)**：大規模モデルを呼び出してセマンティック解析を実行。
*   **行 (Action)**：ツールを操作するための意図を生成。
*   **識 (Integrator)**：すべてのプラグインからの情報を統合し、自己の連続性を維持。

**コアの特性**： **ステートレス (Stateless)** です。すべての状態は「記憶プラグイン」に預けられ、すべての通信仕様は「プロトコルプラグイン」に依存します。これは、コアが異なるコンテナ間を損失なく移行できることを意味します。

---

## 3. 能力プラグイン (The Plugins)

**位置付け：エージェントに個性、専門性、および魂を与える機能コンポーネント。**

### 3.1 データおよびプロトコルプラグイン (Internal Protocol Plugin)
*   **エンジニアリングの詳細**：内部メッセージバス (Internal Bus) を定義。
*   **シナリオ応用**：
    *   **高速モード**：開発者エージェントは Protobuf プロトコルを使用し、超高速なコード生成と転送を追求。
    *   **透明モード**：テスターエージェントは「ログ追跡プロトコル」を使用し、毎秒の神経伝導を記録。エラー発生時に因果関係を遡れるようにする。

### 3.2 評価および進化プラグイン (Reflection Plugin)
*   **エンジニアリングの詳細**： 「二層推論」メカニズムを実装。アクションの出力前に、評価プラグインがインターセプト（セルフチェック）を行う。
*   **シナリオ応用**：
    *   **軽量化**：シンプルなドキュメント整理エージェントなどは、このプラグインを搭載せず遅延を短縮。
    *   **高度な意思決定**：工場の設備操作に関わるエージェントなどは、「物理規則検証」を備えたリフレクションプラグインを必須とし、危険な動作を回避。

### 3.3 状態および記憶プラグイン (Memory Plugin)
*   **エンジニアリングの詳細**：ストレージインターフェース `IMemoryStore` を抽象化。
*   **シナリオ応用**：
    *   **短期的な戦場**： `In-Memory` プラグインを使用し、開発者が現在の関数を記述している際に極めて高速なコンテキスト切り替えを可能にする。
    *   **長期的な経験**： `Vector-RAG` プラグインを搭載し、エージェントが3ヶ月前に同様のバグを解決した経験を記憶。

---

## 4. OpenStarry アーキテクチャの究極の運用フロー (The Lifecycle)

これは「縁起」から「寂滅」までの完全なライフサイクルです。

1.  **縁起 (Origination)**：環境レイヤーがハードウェアエラーを検知。
2.  **スケジューリング (Scheduling)**：スケジューリングレイヤーが「修理専門家」が必要であると判断し、コンテナレイヤーに通知。
3.  **生起 (Arising)**：コンテナレイヤーが **エージェントコア** をロードし、 **診断プロトコル** 、 **高度なリフレクション** 、および **設備知識ベース記憶** の3つのプラグインを接続。
4.  **運用 (Operation)**：エージェントコアはプラグインの支援を受けながら「痛覚」の処理を開始し、修復指令を生成。
5.  **寂滅 (Cessation)**：タスク完了。コンテナレイヤーはコアインスタンスを破棄し、記憶プラグインが経験をデータベースに保存。
