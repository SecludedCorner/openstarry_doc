# 08. MCP：エージェント間の通信プロトコル

このドキュメントでは、洗練されたアーキテクチャの下での MCP (Multi-Component/Agent Communication Protocol) の実装の考え方を詳細に説明します。

## 核心的な位置付け：1つのプロトコル、2つのプラグイン

新しいアーキテクチャでは、 MCP は単一の「メッセージバスエンジン」によって担われるものではありません。代わりに、それは **通信プロトコル仕様** と見なされ、その機能は2つの異なるタイプのプラグインが協調することで実現されます。これにより、システムの疎結合性がさらに高まります。

---

## コンポーネント設計

### 1. `MCP_Listener` プラグイン

*   **プラグインタイプ：** **`listener`**
*   **責務：** MCP の **受信側** を実装します。
*   **ワークフロー：**
    1.  これは長時間実行されるプラグインです。その `start()` メソッド内で、下層のメッセージミドルウェア（例： RabbitMQ, Redis Pub/Sub, または単純な Node.js EventEmitter ）に接続します。
    2.  自身のホストエージェントコア ID 宛のメッセージを購読（サブスクライブ）します。
    3.  メッセージミドルウェアからメッセージを受信すると、そのメッセージが MCP パケット形式に適合しているか検証します。
    4.  検証に合格すると、メッセージパケットをコアの標準イベントオブジェクトに変換します。例：
        ```json
        {
          "source": "mcp_bus",
          "type": "mcp_message",
          "payload": { /* MCP メッセージの body */ }
        }
        ```
    5.  最後に、コアから注入された `eventQueue.push()` メソッドを呼び出し、そのイベントを「内部イベントキュー」にプッシュします。

### 2. `mcp:send` プラグイン

*   **プラグインタイプ：** **`tool`**
*   **責務：** MCP の **送信側** を実装します。
*   **ワークフロー：**
    1.  これは通常の、受動的に呼び出されるツールです。
    2.  LLM がメッセージの送信を決定すると、エージェントコアの「実行ループ」がこのツールの `execute` メソッドを呼び出します。
    3.  `execute` メソッドは、 `target_id`, `action`, `payload` などを含む `args` を受け取ります。
    4.  このメソッドは、これらの `args` を MCP 仕様に準拠したメッセージパケットに組み立てます。
    5.  共有クライアントを介して、このメッセージパケットを下層のメッセージミドルウェアにパブリッシュ（発行）します。

---

## 利点

この設計により、 MCP の具体的な実装がコアから完全に切り離されます。

*   **交換可能なメッセージミドルウェア：** エージェントコアは、下層で RabbitMQ が使われているのか Redis が使われているのかを一切知りません。 `MCP_Listener` プラグインの実装を交換するだけで、コアに一切手を加えることなく、メッセージミドルウェアを簡単に切り替えることができます。
*   **コアの純粋性の維持：** コアの責務は内部イベントキューの処理に厳格に限定され、外部世界とのすべての非同期通信は `Listener` プラグインに抽象化されます。
*   **責務の明確化：** 送信（ `Tool` ）と受信（ `Listener` ）の責務が、2つの異なるタイプのプラグインに明確に分離されます。
