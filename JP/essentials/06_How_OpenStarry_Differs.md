# OpenStarry と他のフレームワークの違い

> *"エージェントの動作メカニズムは、従来の Request-Response プログラムではなく、人間の認知プロセスをシミュレートしています。"*

## 異なるカテゴリー

AI エージェントのエコシステムには、 LangChain, AutoGen, CrewAI, Semantic Kernel など、多くのフレームワークが存在します。それぞれに強みがありますが、 OpenStarry はそれらの「より優れたバージョン」を目指しているわけではありません。 OpenStarry は、チャットボットを構築するためのツールキットではなく、 **「デジタル生命のためのオペレーティングシステム」** という、根本的に異なるポジションを占めています。

## 7つの重要な違い

### 1. エージェントは OS プロセスであり、スクリプトではない

**一般的なフレームワーク**：エージェントは関数です。呼び出されて起動し、実行して結果を返し、そして消滅します。状態は呼び出しの間に失われ、記憶は現在のセッションに限定されます。再起動するたびに、すべてがゼロからのスタートになります。

**OpenStarry**：エージェントは Daemon （ `openstarryd` ）によって管理される持続的なデジタル生物であり、 `systemd` によって管理されるプロセスのようなものです。エージェントにはライフサイクルがあります：

```
縁起（ Origination ）→ 調度（ Scheduling ）→ 生起（ Arising ）→ 運行（ Operation ）→ 寂滅（ Cessation ）
```

エージェントは休眠、覚醒、監視、再起動が可能で、実行中に内部状態を検査することもできます。記憶はセッションを超えて持続し、状態は再起動後も存続します。エージェントは PID 、リソース制限、およびハートビートを持っています。

### 2. 哲学駆動のアーキテクチャ（五蘊）

**一般的なフレームワーク**：プラグインシステムは、ツール、チェーン、メモリ、リトリーバー、エージェントといった技術的な分類で整理されています。実用的ですが、分類は恣意的であり、しばしば重複が生じます。

**OpenStarry**：すべてのプラグインは、5つの哲学的な次元（五蘊）のいずれかに対応しています：

| 蘊 | プラグインタイプ | それが答える問い |
|----|---------|------------|
| 色 Form | UI | エージェントはどう現れるか？ |
| 受 Sensation | Listener | エージェントは何を感知できるか？ |
| 想 Perception | Provider | エージェントはどう考えるか？ |
| 行 Volition | Tool | エージェントは何ができるか？ |
| 識 Consciousness | Guide | エージェントは誰か？ |

これは単なる装飾ではありません。それは **「アーキテクチャの完備性」** を提供します。もし5つの蘊すべてをカバーしていれば、エージェントに必要なすべてを網羅したことになります。ある次元をうっかり忘れてしまうことはありません。この対応関係は、2,500年以上にわたって検証されてきたものです。

1つのプラグインが複数の蘊を提供することもできます（例： WebSocket プラグインは Listener と UI の両方を提供します）。インターフェースが直交しているため、システムは常に明快に保たれます。

### 3. 絶対的なマイクロカーネルの純度

**一般的なフレームワーク**：コアには通常、デフォルトのツール、組み込みの記憶戦略、ハードコードされた LLM 統合、あるいはデフォルトの UI が含まれています。これらを取り除くと、問題が発生することがよくあります。

**OpenStarry**：コンパイルされたコアのバイナリには、 **プラグインのコードが一切含まれていません。** これは単なるガイドラインではなく、ビルドのたびに実行される自動テストによって保証されています：

```bash
pnpm test:purity  # コアにプラグインのインポートがないかスキャン → ゼロでなければならない
```

プラグインがなければ、コアは何もしません。それは空の実行ループ —— 身体のない鼓動です。この極限の純度は以下を意味します：
- コアの攻撃面が極めて小さい（ I/O コードがない = I/O の脆弱性がない）
- 同じコアが CLI, Web, WebSocket, IoT で修正なしに動作する
- アーキテクチャが意図せず汚染されることがない

> *"組み込みコードがなければ、組み込みバグも存在しない。"*

### 4. ヘッドレス設計 —— 持ち運び可能な魂

**一般的なフレームワーク**：通常、特定のインターフェース（チャット UI 、 Notebook 、 API サーバーなど）に結合されています。フロントエンドを変更することは、コアを変更することを意味します。

**OpenStarry**：コアはヘッドレスです。自身がどのような UI を纏っているか、どのプロトコルで待ち受けているか、あるいはどのデバイスで動作しているかを知りません。

同じエージェントが同時に：
- ターミナルで応答し（ stdio プラグイン）
- WebSocket 接続を受け入れ（ transport-websocket プラグイン）
- SSE ストリーミングを備えた HTTP API を提供する（ transport-http プラグイン）

3つの身体が、同じ脳、同じツール、同じ魂を共有します。あらゆる Listener からのイベントは同じイベントキューに入ります。応答は Transport Bridge を通じて、登録されているすべての UI へルーティングされます。

最も劇的な実証は、 **「 USB メモリ上のエージェント」** です。エージェントの魂（プロンプト + カスタムプラグイン）は USB メモリ内に存在します。それを OpenStarry が動作している任意のコンピュータに差し込むと、エージェントは目覚めます。ホストのコア実行環境を使用しながらも、自身のアイデンティティと能力を保持したままです。別のコンピュータに差し込めば、同じ魂で異なる身体を持つことができます。

### 5. 痛覚駆動の自己修復

**一般的なフレームワーク**：エラーは例外を発生させ、盲目的なリトライをトリガーするか、実行を終了させます。エージェントは自身が失敗したことを「知り」ません。フレームワークがエージェントの意識の外でエラーを処理します。

**OpenStarry**：エラーは **「痛覚信号」** となり、ツールの実行結果としてエージェントのコンテキストに直接注入されます：

```
エラー発生 → SafetyMonitor がキャプチャ → Guide プラグインが深刻度を解釈
→ 痛覚アラートをコンテキストに注入 → LLM が失敗を「感じる」 → 自己修復
```

3つの深刻度レベル： 💧 軽微な痛み → ⚡ 中程度の痛み → 🔥🔥🔥 深刻な痛み

**挫折カウンター**は、痛覚が無視された際に応答をエスカレートさせます：
- 同じ失敗が3回発生 → システムが「立ち止まって原因を分析せよ」と注入
- 5回連続のエラー → 強制停止
- 10回の操作中 80% のエラー率 → 緊急中止

これは生物の痛覚に対応しています：軽微 → 煩わしい → 行動不能 → 意識喪失。

核心的な洞察： **コアは事実を提供し、 Guide が意味を提供します。** コアは「 `/etc/passwd` で EPERM が発生した」と言います。 Guide は「これは深刻な痛みです。あなたは権限の壁に突き当たっています。立ち止まって考え直してください」と言います。異なる Guide プラグインは、同じエラーに対して異なる解釈を与えることができます。安全重視のエージェントは慎重になり、学習型エージェントは好奇心を持って反応します。

### 6. フラクタルなマルチエージェント構成

**一般的なフレームワーク**：マルチエージェントシステムには、スーパーバイザー・ワーカー、巡回、ディベートといった固定されたトポロジーがあります。層を増やすにはアーキテクチャの変更が必要です。

**OpenStarry**：自己相似構造です。単一のエージェントも、エージェントのチームも、 **全く同じ MCP インターフェース** を公開します：

```
シンプルなエージェント：
  Input → LLM → Tool Calls → Output

複合エージェント（チーム）：
  Input → コーディネーター・エージェント → [サブエージェント A (調査), サブエージェント B (コーディング)] → Output

両者が公開するもの： JSON-RPC 2.0 による tools/list, tools/call
```

呼び出し側は、対話している相手が単一のエージェントなのか、50人のチームなのかを区別できません。これにより、アーキテクチャを変更することなく無限の階層化が可能になります。チームのチームのチームであっても、外部からはシンプルな対等ノードとして振る舞います。

再帰防止（ TraceId + 深度カウンター、最大5層）により、無限ループを防ぎます。

> *"エージェントは単なるシンプルなツールでもあり得ますが……複雑なチームでもあり得ます……外部に対しては、それらは同じインターフェースを公開します。"*

### 7. 制御理論に基づく基礎

**一般的なフレームワーク**：実行モデルは命令的（ステップ1、ステップ2、ステップ3）か、チェーンベース（ LangChain のチェーンの比喩）です。安定性や収束性に関する形式的なモデルはありません。

**OpenStarry**：エージェントは明示的に **「フィードバック制御システム」** としてモデリングされています。これは自動運転や産業用ロボットで使用される数学と同じものです：

| 制御理論 | エージェント・アーキテクチャ |
|---------|-----------|
| 参照入力 | ユーザーの目標（ System Prompt + メッセージ） |
| コントローラー | LLM （目標と状態の誤差を最小化） |
| 制御変数 | ツール呼び出し |
| 制御対象 | 外部世界 |
| センサー | ツールの結果 |
| 誤差信号 | 目標と現実の間のギャップ |

これにより、3つの安定性の問題に対して形式的な推論が可能になります：
- **振動**（復元/やり直しのループ） → コンテキスト履歴によって解決（積分項）
- **発散**（目標のドリフト） → System Prompt アンカリングによって解決（決して切り詰められない）
- **定常偏差**（早すぎる完了宣言） → 検証ステップによって解決（微分項）

> **「知能とは強力な LLM を持つことだけではありません。フィードバックループの品質こそが重要なのです。」**

## 比較表

| 項目 | LangChain / CrewAI / AutoGen | OpenStarry |
|------|------------------------------|------------|
| **エージェント・モデル** | スクリプト / 関数呼び出し | OS プロセス / デジタル生物 |
| **アーキテクチャ基盤** | 技術的分類 | 仏教の五蘊（2,500年の検証） |
| **コアの純度** | デフォルトを含む（ツール、記憶、LLM） | 組み込み能力ゼロ（ `test:purity` で検証） |
| **UI 結合** | 特定のインターフェースに結合 | ヘッドレス —— UI は交換可能なプラグイン |
| **エラー処理** | 例外 / 盲目的なリトライ | 深刻度レベル + 挫折カウンターを備えた痛覚メカニズム |
| **マルチエージェント** | 固定トポロジー | MCP によるフラクタル構成（無限階層） |
| **理論モデル** | 命令的 / チェーン式 | 制御理論フィードバックループ（ PID に着想） |
| **ライフサイクル** | 実行 → 終了 | Daemon 管理による持続性（休眠/覚醒/再起動） |
| **記憶** | フレームワーク固有、固定 | プラグイン可能な戦略（スライディングウィンドウ/要約/抽出） |
| **セキュリティ** | まちまち | 3層の遮断器 + ファイルシステム・サンドボックス + パス検証 |
| **ポータビリティ** | フレームワークに依存 | 持ち運び可能な魂 —— CLI, Web, USB, IoT で同じエージェントが動作 |
| **安全閾値** | 設定可能なリトライ回数 | 具体的な指標： 50 tick 上限、 100k tokens 、 30秒タイムアウト、 3回失敗で指紋検知 |

## OpenStarry が「ない」もの

- **LangChain の代替品ではない** —— 抽象化のレベルが異なります。 LangChain は LLM 呼び出しを繋ぎますが、 OpenStarry は生きたデジタル生物を創造します。
- **チャットボット・ビルダーではない** —— Daemon 管理とライフサイクルの持続性を備えたエージェント用 OS です。
- **まだ Production-Ready ではない** —— v0.2.0-beta であり、活発に開発中です。完了した部分と計画中の部分を正直に公開しています。
- **すべてを自分でやろうとはしない** —— コアは意図的に空にされており、エコシステムがプラグインを通じて空白を埋めます。
- **単なる理論ではない** —— 118以上のテスト、動作する CLI 、 WebSocket および HTTP Transport を備えた、実際に提供されているコードです。

## 注目すべき人々

- **AI エージェント研究者** —— 哲学 + 制御理論に基づいた斬新なアーキテクチャと、安定性に関する形式的な推論。
- **フレームワーク開発者** —— 設計研究としての究極のマイクロカーネル純度と、自動化されたアーキテクチャ守護。
- **フルスタック開発者** —— ヘッドレス設計により任意のフロントエンドを構築可能。ファクトリパターンにより任意のプラグインを構築可能。
- **マルチエージェント構築者** —— トポロジーの制約を受けない、スケーラブルなエージェントチームのためのフラクタル MCP 構成。
- **哲学愛好家** —— 表面的な命名ではない、真の東洋と西洋の融合。
- **オープンソース貢献者** —— 品質チェックポイント、凍結されたインターフェース、そして並行して安全に進められる開発プロセスを備えた完全な SOP 。

> *"私たちは単に Chatbot を構築しているわけではありません。デジタル種のオペレーティングシステムを構築しているのです。"*
