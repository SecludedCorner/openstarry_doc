# OpenStarry の開発手法：マルチエージェント開発

> OpenStarry は単なる AI エージェントフレームワークではありません。**AI エージェントによって構築された** AI エージェントフレームワークです。

## 6体エージェントチーム

OpenStarry は、正式な標準作業手順（SOP）に基づいて運用される6体の専門 AI エージェントチームによって開発されています。各エージェントには定義された役割、専用のワークスペース、構造化された成果物の要件があります。これはデモ用のトイプログラムではなく、アーキテクチャレビュー済み、品質検証済み、ドキュメント化されたコードを生産する本格的なソフトウェアエンジニアリングプロセスです。

### チーム構成

| エージェント | 役割 | モデル | ワークスペース | 成果物 |
|------------|------|--------|-------------|--------|
| **Architect** | アーキテクチャガーディアン | Sonnet | ドキュメント + コード（読み取り専用） | 設計仕様書、コードレビュー、セキュリティ監査 |
| **Dev-Core** | コア開発者 | Sonnet | `agent_dev/openstarry/` | SDK、Core、Shared、Runner の実装 |
| **Dev-Plugin** | プラグイン開発者 | Sonnet | `agent_dev/openstarry_plugin/` | トランスポート、プロバイダー、ツール、ガイドプラグイン |
| **QA** | 品質保証 | Sonnet | `agent_test/`（隔離されたコピー） | ビルド検証、テストレポート、ピュリティチェック |
| **Doc-Keeper** | ドキュメント管理者 | Haiku | `share/openstarry_doc/` | 意思決定記録、イテレーションログ、ドキュメント更新 |
| **Researcher** | 技術リサーチャー | Sonnet | `share/ref/` | 事前調査レポート、リファレンスプロジェクト分析 |

人間の**コーディネーター**が Claude Opus を使用してチームをオーケストレーションし、最終決定を下し、紛争を解決し、サイクル遷移を管理します。

### なぜこの構造なのか

各役割には存在理由があります：

- **Architect** はアーキテクチャの劣化を防止します。これがなければ、ショートカットの蓄積により五蘊の純粋性が徐々に低下します。Architect はすべてのコミットに対してコンプライアンスを強制します。
- **Dev-Core と Dev-Plugin を分離**することで、SDK インターフェースが凍結されているため、両者が並行作業できます。Dev-Core がフレームワークを構築している間に、Dev-Plugin がその上に構築します — 同時進行で。
- **QA は隔離されたコピーで作業**します（`agent_test/`）。開発ディレクトリではありません。これにより、古典的な「自分のマシンでは動く」問題を防止します — テスト環境で合格すれば、本当に合格です。
- **Doc-Keeper はより軽量なモデルを使用**します（Haiku）。ドキュメントの更新にはコード生成ほどの推論力は必要ありませんが、一貫性と徹底性が求められるからです。
- **Researcher** は実装開始前に事前調査を行い、リファレンスプロジェクト（エージェントルーティングの OpenClaw、TUI パターンの OpenCode、MCP 統合の OpenOctopus）を研究して設計判断に情報を提供します。

## イテレーションサイクル

すべての機能は品質ゲート付きの規律ある8フェーズサイクルを経ます：

### フェーズ 0：計画
```
Coordinator: "サイクル 1 のスコープ：セッション隔離 + HTTP SSE + ヘルスチェック"
Researcher: トランスポートパターン、SSE のベストプラクティス、セッション管理戦略を調査
Doc-Keeper: サイクル ID（20260210_cycle1）とともに計画を Iteration_Log.md に記録
```

### フェーズ 1：設計
```
Architect: Architecture_Spec_Cycle1.md を作成：
  - 新規/変更インターフェース（ISession、ISessionManager、InputEvent.sessionId）
  - セッションライフサイクルのシーケンス図
  - セキュリティ考慮事項（セッション隔離によるクロストーク防止）

⚠️ インターフェース凍結：公開後、正式な Spec Addendum なしにインターフェースは変更不可
```

### フェーズ 1.5：ベースライン
```
Coordinator: scripts/baseline.sh を実行 → 実装前のスナップショットを保存
  └─ セーフティネット：何か問題が発生した場合、このポイントに復元
```

### フェーズ 2：実装
```
フェーズ 2a: Dev-Core が最初に SDK インターフェースの変更を実装
  └─ @openstarry/sdk に ISession、ISessionManager を追加
  └─ InputEvent にオプショナルな sessionId フィールドを追加（後方互換）
  └─ フェーズ 2b 開始前に pnpm build がパスする必要がある

フェーズ 2b: Dev-Core + Dev-Plugin が並行作業
  └─ Dev-Core：セッションマネージャー、実行ループのセッションルーティング
  └─ Dev-Plugin：WebSocket セッションバインディング、HTTP SSE エンドポイント
  └─ 各自が判断、課題、解決策を含む構造化された DevLog を作成
```

### フェーズ 2.5：同期
```
Coordinator: scripts/sync-to-test.sh を実行
  └─ agent_dev/ → agent_test/ へのアトミックコピー
  └─ テスト環境に開発コードの正確なコピーを確保
  └─ テスト環境での pnpm build がパスする必要がある
```

### フェーズ 3：検証（並行）
```
QA（agent_test/ で）：                   Architect（agent_dev/ を読み取り）：
├─ pnpm build → 全 11 パッケージがパス   ├─ 五蘊コンプライアンスチェック
├─ pnpm test → 118+ テストがパス         ├─ マイクロカーネルピュリティレビュー
├─ pnpm test:purity → 違反ゼロ           ├─ セキュリティ監査
└─ QA_Report_Cycle1.md を作成            └─ CodeReview_Cycle1.md を作成
```

### フェーズ 4：収束
```
PASS: Coordinator が scripts/snapshot.sh を実行 → バージョン付きスナップショットを保存
FAIL: 問題を分類：
  ├─ コード修正 → フェーズ 2 に戻る（実装のバグ）
  ├─ 設計修正 → フェーズ 1 に戻る（アーキテクチャの問題）
  └─ 計画修正 → フェーズ 0 に戻る（要件の問題）

人間にエスカレーションするまで最大 2 回のリワークサイクル
```

## 品質ゲート

### インターフェース凍結
Architect が Architecture Spec を公開すると、インターフェースは凍結されます。Dev-Core はそれを実装できますが、変更はできません。これにより、ほとんどのプロジェクトを悩ませるスコープクリープとインターフェースの不安定性を防止します。インターフェースの変更が必要な場合、正式な Spec Addendum — 意図的でレビューされたプロセス — が必要です。

### マイクロカーネルピュリティ検証
QA は `pnpm test:purity` を実行し、コンパイル済み Core バイナリにプラグインのインポートがないかスキャンします。**違反はゼロでなければなりません。** この自動化されたゲートにより、時間の経過とともにマイクロカーネルアーキテクチャを侵食する漸進的な汚染を防止します。

### テスト隔離
QA は開発ディレクトリでテストしません。同期スクリプトが別の `agent_test/` 環境にコードをコピーします。開発者がローカル状態でのみテストをパスさせる一時的なハックを残していた場合、QA がそれを検出します。

### リワーク分類
すべての失敗が同等ではありません：
- **コード修正** → 迅速なパッチ、フェーズ 2 に戻る
- **設計修正** → インターフェース変更が必要、フェーズ 1 に戻る（Spec Addendum が必要）
- **計画修正** → 要件が誤っていた、フェーズ 0 に戻る（稀ですが深刻）

## 構造化された成果物

すべてのサイクルがトレーサブルで構造化されたレポートを生成します：

```
share/test/reports/
├── research/20260210_cycle1/
│   └── Research_Transport_Enhancement.md      ← Researcher
├── arch_reviews/20260210_cycle1/
│   ├── Architecture_Spec_Cycle1.md            ← Architect（凍結済み）
│   └── CodeReview_Cycle1.md                   ← Architect
├── dev_logs/20260210_cycle1/
│   ├── DevLog_Phase2a_SDK_Core.md             ← Dev-Core
│   └── DevLog_Phase2b_Transport_Plugins.md    ← Dev-Plugin
├── qa_results/20260210_cycle1/
│   └── QA_Report_Cycle1.md                    ← QA
└── sys_summary/20260210_cycle1/
    └── Convergence_Summary.md                 ← Coordinator
```

すべてサイクル ID（`{YYYYMMDD}_cycle{N}`）で命名され、完全なトレーサビリティを確保しています。6ヶ月後でも、任意のコード行を、それを動機づけた調査、それを定義した仕様、それを実装した開発ログ、それを検証した QA レポートまで遡ることができます。

## コミュニティにとっての意味

OpenStarry がリリースされるとき、コントリビューターは以下を引き継ぎます：

1. **完全な開発プロセス** — コードだけでなく、作業の仕方
2. **アーキテクチャのガードレール** — 自動化されたピュリティテストにより、善意のコントリビューションがアーキテクチャを侵食することを防止
3. **トレーサブルな意思決定** — すべての「なぜ」がドキュメント化され、チャット履歴に埋もれることがない
4. **並行安全な開発** — Dev-Core と Dev-Plugin は別々のコントリビューターとして同時に作業可能。SDK インターフェースが凍結されているため
5. **再現可能な品質** — SOP は開発者が人間でも AI でも同じ

> プロセスはプロダクトの一部です。
