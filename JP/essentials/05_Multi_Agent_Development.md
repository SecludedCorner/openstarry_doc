# OpenStarry はどう作られたか：マルチエージェント開発

> OpenStarry は単なる AI エージェント・フレームワークではありません。それは、 **AI エージェントによって構築された** AI エージェント・フレームワークです。

## 6つのエージェントチーム

OpenStarry は、正式な標準操作手順 (SOP) に従い、6名の専門 AI エージェントからなるチームによって開発されています。各エージェントには明確な役割、専用のワークスペース、および構造化された成果物の要件があります。これはお遊びのデモンストレーションではなく、アーキテクチャ審査、品質検証、完全なドキュメント化を経たコードを生み出す、真のソフトウェア・エンジニアリング・プロセスです。

### チームメンバー

| エージェント | 役割 | モデル | ワークスペース | 成果物 |
|-------|------|------|--------|------|
| **Architect** | アーキテクチャの守護者 | Sonnet | ドキュメント + コード（読み取り専用） | 設計仕様、コードレビュー、セキュリティ監査 |
| **Dev-Core** | コア開発者 | Sonnet | `agent_dev/openstarry/` | SDK, Core, Shared, Runner の実装 |
| **Dev-Plugin** | プラグイン開発者 | Sonnet | `agent_dev/openstarry_plugin/` | Transport, Provider, Tool, Guide プラグイン |
| **QA** | 品質保証 | Sonnet | `agent_test/` （隔離コピー） | ビルド検証、テスト報告、純度チェック |
| **Doc-Keeper** | ドキュメント管理者 | Haiku | `share/openstarry_doc/` | 意思決定記録、反復ログ、ドキュメント更新 |
| **Researcher** | 技術研究員 | Sonnet | `share/ref/` | 事前調査報告書、リファレンスプロジェクト分析 |

1人の人間である **コーディネーター** が Claude Opus を使用してチームを指揮し、最終決定を下し、紛争を解決し、サイクルの移行を管理します。

### なぜこのような構造なのか？

各役割の存在には理由があります：

- **Architect** はアーキテクチャの侵食を防ぎます。これがなければ、近道（手抜き）の蓄積とともに五蘊（ごうん）の純度は徐々に低下してしまいます。 Architect は、すべてのコミットに対してコンプライアンスチェックを強制します。
- **独立した Dev-Core と Dev-Plugin** エージェントは、 SDK インターフェースが凍結されているため、並行して作業できます。 Dev-Core がフレームワークを構築し、 Dev-Plugin がそのフレームワークに基づいて開発を行う —— これを同期して進めます。
- **QA は隔離されたコピーで作業します** （ `agent_test/` ）。開発ディレクトリではありません。これにより、古典的な「自分のマシンでは動く」という問題を防ぎます。テスト環境でパスすれば、それは本当にパスしたことになります。
- **Doc-Keeper は軽量なモデル** （ Haiku ）を使用します。ドキュメントの更新にはコード生成のような推論能力は必要ありませんが、一貫性と完全性を維持する必要があるからです。
- **Researcher** は実装開始前に事前調査を行い、リファレンスプロジェクト（エージェントルーティング用の OpenClaw 、 TUI パターン用の OpenCode 、 MCP 統合用の OpenOctopus ）を研究し、設計決定の根拠を提供します。

## 反復サイクル (Iteration Cycle)

各機能は、品質のチェックポイント（関門）を備えた厳格な8段階のサイクルを経て開発されます：

### フェーズ 0：計画
```
Coordinator: "Cycle 1 の範囲：セッション隔離 + HTTP SSE + ヘルスチェック"
Researcher: トランスポートパターン、 SSE のベストプラクティス、セッション管理戦略を調査
Doc-Keeper: Iteration_Log.md に計画を記録し、サイクル ID（20260210_cycle1）を付与
```

### フェーズ 1：設計
```
Architect: Architecture_Spec_Cycle1.md を作成。以下を含む：
  - 新規/修正インターフェース（ISession, ISessionManager, InputEvent.sessionId）
  - セッションライフサイクルのシーケンス図
  - セキュリティ上の考慮事項（セッションをまたぐ干渉を防ぐためのセッション隔離）

⚠️ インターフェース凍結：一度発行されると、正式な仕様追記 (Spec Addendum) を経ない限り、インターフェースは変更不可
```

### フェーズ 1.5：ベースライン・バックアップ
```
Coordinator: scripts/baseline.sh を実行 → 実装前のスナップショットを保存
  └─ 安全網：問題が発生した場合、この時点まで復元可能
```

### フェーズ 2：実装
```
Phase 2a: Dev-Core が先に SDK インターフェースの変更を実装
  └─ ISession, ISessionManager を @openstarry/sdk に追加
  └─ InputEvent にオプションの sessionId フィールドを追加（後方互換性維持）
  └─ pnpm build が通過しなければ Phase 2b へ進めない

Phase 2b: Dev-Core + Dev-Plugin が並行して作業
  └─ Dev-Core: セッションマネージャー、実行ループのセッションルーティング
  └─ Dev-Plugin: WebSocket セッションバインド、 HTTP SSE エンドポイント
  └─ 各自が構造化された DevLog を作成し、決定事項、課題、解決策を記録
```

### フェーズ 2.5：同期
```
Coordinator: scripts/sync-to-test.sh を実行
  └─ agent_dev/ から agent_test/ へ原子的にコピー
  └─ テスト環境が開発コードの完全なコピーを保持していることを保証
  └─ テスト環境での pnpm build が通過しなければならない
```

### フェーズ 3：検証（並行実施）
```
QA（ agent_test/ 内）：                    Architect（ agent_dev/ を読み取り）：
├─ pnpm build → 全11パッケージ通過        ├─ 五蘊コンプライアンスチェック
├─ pnpm test → 118以上のテスト通過        ├─ マイクロカーネル純度審査
├─ pnpm test:purity → 違反ゼロ            ├─ セキュリティ監査
└─ QA_Report_Cycle1.md を作成             └─ CodeReview_Cycle1.md を作成
```

### フェーズ 4：収束
```
PASS: Coordinator が scripts/snapshot.sh を実行 → バージョン管理されたスナップショットを保存
FAIL: 問題の分類：
  ├─ Code Fix → フェーズ 2 へ戻る（実装上のバグ）
  ├─ Design Fix → フェーズ 1 へ戻る（アーキテクチャ上の問題）
  └─ Plan Fix → フェーズ 0 へ戻る（要件上の問題）

リワークサイクルは最大2回まで。その後は人間による処理へエスカレーション
```

## 品質チェックポイント

### インターフェースの凍結
Architect が Architecture Spec を発行すると、インターフェースは凍結されます。 Dev-Core はそれらを実装できますが、変更することはできません。これにより、多くのプロジェクトを悩ませるスコープクリープ（範囲の肥大化）やインターフェースの不安定さを防ぎます。インターフェースの変更が必要な場合は、正式な Spec Addendum（意図的で、精査されたプロセス）を経る必要があります。

### マイクロカーネル純度の検証
QA は `pnpm test:purity` を実行し、コンパイルされた Core バイナリにいかなるプラグインのインポートも含まれていないかをスキャンします。 **いかなる違反も許されません。** この自動化された関門により、時間の経過とともにマイクロカーネル・アーキテクチャを徐々に侵食する汚染を防ぎます。

### テストの隔離
QA は決して開発ディレクトリでテストを行いません。同期スクリプトがコードを独立した `agent_test/` 環境にコピーします。開発者がローカルな状態でのみテストをパスさせるような一時的な修正を残していた場合、 QA はそれを捕らえます。

### リワークの分類
すべての失敗が同じではありません：
- **Code Fix** → 迅速なパッチを当て、フェーズ 2 へ戻る
- **Design Fix** → インターフェースの変更が必要。フェーズ 1 へ戻る（ Spec Addendum が必要）
- **Plan Fix** → 要件に誤りがあった。フェーズ 0 へ戻る（稀だが深刻）

## 構造化された成果物

各サイクルは、追跡可能な構造化された報告書を生成します：

```
share/test/reports/
├── research/20260210_cycle1/
│   └── Research_Transport_Enhancement.md      ← Researcher
├── arch_reviews/20260210_cycle1/
│   ├── Architecture_Spec_Cycle1.md            ← Architect（凍結済み）
│   └── CodeReview_Cycle1.md                   ← Architect
├── dev_logs/20260210_cycle1/
│   ├── DevLog_Phase2a_SDK_Core.md             ← Dev-Core
│   └── DevLog_Phase2b_Transport_Plugins.md    ← Dev-Plugin
├── qa_results/20260210_cycle1/
│   └── QA_Report_Cycle1.md                    ← QA
└── sys_summary/20260210_cycle1/
    └── Convergence_Summary.md                 ← Coordinator
```

すべてのファイルはサイクル ID（ `{YYYYMMDD}_cycle{N}` ）で命名され、完全な追跡可能性を保証します。半年後であっても、あらゆるコード行を、それを触発した研究、それを定義した仕様書、それを実装した開発ログ、そしてそれを検証した QA 報告書まで遡ることができます。

## これがコミュニティにとって何を意味するか

OpenStarry がリリースされたとき、コントリビューターが継承するのは単なるコードではありません：

1. **一連の完全な開発プロセス** —— コードだけでなく、仕事の進め方そのもの
2. **アーキテクチャのガードレール** —— 自動化された純度テストが、善意の貢献によるアーキテクチャの侵食を防ぐ
3. **追跡可能な意思決定** —— あらゆる「なぜ」がドキュメント化されており、チャット履歴の中に埋もれることがない
4. **並行して安全に進められる開発** —— SDK インターフェースが凍結されているため、 Dev-Core と Dev-Plugin は同時に作業する別のコントリビューターであっても構わない
5. **再現可能な品質** —— 開発者が人間であれ AI であれ、 SOP は同じである

> プロセスそのものが製品の一部です。
